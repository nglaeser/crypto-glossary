{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How to Use This Glossary","text":"<p>For the most part, I use a standard glossary style, that is,</p> Term This is the definition of the term. I might bold other terms being defined inside the definition. <p>I use the following callouts for specific examples, summaries, etc.:</p> <p>Example/Construction</p> <p>Examples or specific constructions that realize some cryptographic primitive.</p> <p>Notation</p> <p>For comments about notation.</p> <p>Summary</p> <p>Duh.</p> <p>Info</p> <p>Usually include some formal definition or theorem.</p> <p>Further Reading</p> <p>Pointers to some additional material.</p> <p>Warning</p> <p>Draw attention to some small but significant detail.</p>"},{"location":"assumptions/","title":"Assumptions","text":"<p>This page lists common hardness assumptions upon which cryptographic schemes have been based. These range from standard (widely used and believed to hold) to newer assumptions (recently introduced and less well-tested).</p> <p>Computing the requested answer in each of these cases is believed to be hard. Since the assumptions useful in cryptography are largely computational assumptions, \"hard to compute\" means computationally intractable (typically in polynomial time).</p> <p>See also Wikipedia for a list of cryptographic hardness assumptions. Assumptions marked with  are thought to be post-quantum secure.</p>"},{"location":"assumptions/#types-of-assumptions","title":"Types of Assumptions","text":"Subexponential assumptions Instead of assuming hardness against any adversary running in polynomial time, we make the (stronger) assumption that the problem remains hard even against adversaries running in any subexponential time (so we give the adversary more computational power). Knowledge assumption ... These types of assumptions are non-falsifiable. (Non-)Falsifiable Average-case hardness When a randomly selected instance of the problem is hard to solve. Worst-case hardness When a randomly selected instance of the problem is not necessarily hard to solve, but rather only a carefully crafted \"worst case\" instance. Decisional vs. Computational (aka Search) <p>A decisional problem is of the form \"given an input z of the form X or Y, decide whether X or Y was given\". A computational problem is of the form \"given some input, compute an output meeting some condition\". (See the DDH and CDH assumptions below for an example.)</p> <p>In general, solving the computational variant of a problem implies solving the decisional variant; equivalently, the decisional variant is stronger, i.e., decisional hardness \u21d2 computational hardness in general.</p>"},{"location":"assumptions/#list-of-assumptions","title":"List of Assumptions","text":""},{"location":"assumptions/#discrete-logarithm","title":"Discrete logarithm","text":"<p>Discrete Logarithm Problem (DLog/DLP/DL)</p> AssumptionApplications <p>Let \\(\\mathbb{G}\\) be a group. Given: \\(a,b \\in \\mathbb{G}\\) Compute: k such that \\(b^k=a\\)</p> <ul> <li>Digital Signature Algorithm (DSA)</li> <li>Schnorr signatures</li> </ul>"},{"location":"assumptions/#diffiehellman-dh-assumptions","title":"Diffie\u2013Hellman (DH) assumptions","text":"<p>Computational Diffie\u2013Hellman (CDH)</p> Classic AssumptionComputational co-Diffie\u2013Hellman (co-CDH)Applications <p>Let \\(\\mathbb{G}\\) be a cyclic group of order \\(q\\). Choose a random generator \\(g\\) and let \\(a,b\\) be uniform and independent integers in \\({0, ..., q-1}\\): Given: \\((g, g^a, g^b)\\) Compute: \\(g^{ab}\\)</p> <p>Let \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\) be cyclic groups. Given: \\((g,g^a,h)\\) where \\(g,g^a \\in \\mathbb{G}_1\\) and \\(h \\in \\mathbb{G}_2\\) Compute: \\(h^a \\in \\mathbb{G}_2\\)</p> <ul> <li>Diffie\u2013Hellman Key Exchange (CDH)</li> </ul> <p> </p> <p>Decisional Diffie-Hellman (DDH)</p> <p>Warning</p> <p>Importantly, the DDH assumption is believed to hold only in certain groups.</p> Classic AssumptionDecisional co-Diffie-Hellman (co-DDH)Applications <p>Let \\(\\mathbb{G}\\) be a cyclic group of order \\(q\\) with generator \\(g\\). Let \\(a,b,c\\) be uniform and independent integers in \\({0, ..., q-1}\\): Given: \\((g,g^a,g^b,g^{ab})\\)<sup>1</sup> or \\((g,g^a,g^b,g^c)\\) Decide: Which type of tuple was given?</p> <p>Let \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\) be cyclic groups with generators \\(g\\) and \\(h\\). Given: \\((g,g^a,h,h^b)\\) Decide: Does \\(a=b\\)?</p> <ul> <li>ElGamal encryption (DDH)</li> <li>Cramer\u2013Shoup cryptosystems (DDH)</li> </ul> <p> </p> <p>Gap Diffie-Hellman (GDH)</p> Classic AssumptionGap co-Diffie\u2013Hellman (co-GDH)Applications <p>Let \\mathbb{G} be a group in which the DDH problem is easy but the CDH problem is hard (this is called a gap group). The assumption is that CDH is still hard in these groups.</p> <p>Let \\(\\mathbb{G}_1\\) and \\(\\mathbb{G}_2\\) be cyclic groups in which co-DDH is easy but co-CDH is hard. The assumption is that co-CDH is still hard.</p> <ul> <li>BLS digital signature (co-GDH)</li> </ul> <p></p> <p>External Diffie\u2013Hellman (XDH) / asymmetric XDH</p> AssumptionApplications <p>Assumes the existence of elliptic-curve subgroups \\((\\mathbb{G}_1, \\mathbb{G}_2)\\) such that</p> <ol> <li>DLog, CDH, and co-CDH are hard in both groups  </li> <li>DDH is hard in \\(\\mathbb{G}_1\\) </li> <li>There is an efficiently computable bilinear map \\(e(\\cdot, \\cdot): \\mathbb{G}_1 \\times \\mathbb{G}_2 \\mapsto \\mathbb{G}_T\\). </li> </ol> <ul> <li>Elliptic-curve cryptography (ECC), specifically type-2 pairings</li> </ul> <p></p> <p>Symmetric External Diffie\u2013Hellman (SXDH)</p> AssumptionApplicationsNotes <p>The same as XDH, but additionally assumes in (2) that DDH is also hard in \\(\\mathbb{G}_2\\). </p> <ul> <li>Elliptic-curve cryptography (ECC), specifically type-3 pairings</li> </ul> <ul> <li>Implies XDH</li> </ul>"},{"location":"assumptions/#factoring","title":"Factoring","text":"<p>RSA Assumption</p> AssumptionApplications <p>This assumption corresponds exactly to finding the plaintext (\\(y\\)) of an RSA ciphertext (\\(x\\)) given only the public key \\((n,e)\\). Let \\(n=pq\\) for two large primes \\(p,q\\) and \\(2 &lt; e &lt; n\\) (equivalently, \\(\\gcd(e,n)=1\\)).</p> <p> Given: \\(e,x,n\\) Compute: \\(y\\) such that \\(y^e = x \\pmod{n}\\)</p> <ul> <li>RSA encryption</li> </ul> <p></p> <p>Hardness of factoring large numbers</p> AssumptionApplications <p>Given a \"sufficiently large\" composite number, there is no efficient algorithm for decomposing it into a product of smaller integers. (The hardest instances of this problem are of the form \\(n=pq\\) for large random primes \\(p,q\\) of similar magnitude; \\(n\\) is sometimes called a semiprime)</p> <ul> <li>RSA encryption</li> </ul>"},{"location":"assumptions/#lattice-assumptions","title":"Lattice Assumptions","text":"<p>Learning With Errors (LWE) </p> Assumption (computational)Assumption (decisional)Applications <p>Let \\(\\mathbf{A}\\) be a \\(m \\times n\\) matrix of (uniformly random) integers modulo \\(q\\) and \\(\\vec{e},\\vec{s}\\) be vectors of length \\(m\\), where \\(\\vec{e}\\) is sampled according to some error distribution \\(\\chi\\) and \\(\\vec{s}\\) consists of uniform integers modulo \\(q\\).  </p> <p>That is, \\(\\mathbf{A} \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q^{m \\times n}\\), \\(\\vec{s} \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q^m\\), \\(\\vec{e} \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\chi\\).</p> <p> Given: \\(\\mathbf{A},\\vec{b} := \\mathbf{A} \\cdot \\vec{s} + \\vec{e}\\) Compute: \\(\\vec{s} \\in \\mathbb{Z}_q^n\\) such that \\(\\mathbf{A}\\cdot \\vec{s} + \\vec{e} = \\vec{b} \\pmod{q}\\)</p> <p>Let \\(\\mathbf{A},\\vec{s},\\vec{e},\\vec{b}\\) be initialized as in the computational assumption.</p> <p> Given: Either \\((\\mathbf{A},\\vec{b})\\) or \\((\\mathbf{A},\\vec{u})\\), where \\(\\vec{u} \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q^m\\) Decide: Whether the given tuple was of the form \\((\\mathbf{A},\\vec{b}:=\\mathbf{A}\\cdot \\vec{s} + \\vec{e})\\) or \\((\\mathbf{A},\\vec{u})\\).</p> <ul> <li>NIZKs</li> <li>Public-key encryption</li> </ul> <p></p> <p>Short Integer Solution (SIS) </p> AssumptionApplications <p>The problem is parameterized by a \"small\" scalar \\(\\beta\\) (some discussion of bounds on \\(\\beta\\) can be found here).</p> <p> Given: \\(\\mathbf{A} \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q^{n \\times m}\\) Compute: \\(\\vec{x} \\in \\mathbb{Z}_q^m\\) such that \\(\\lVert \\vec{x} \\rVert &lt; \\beta\\) and \\(\\mathbf{A} \\cdot \\vec{x} = \\vec{0}\\)</p> <ul> <li>Trapdoor functions (and therefore signatures)</li> </ul> <p></p> <p>Shortest Vector Problem (SVP) </p>"},{"location":"assumptions/#other","title":"Other","text":"<p>Learning Parity with Noise (LPN) </p> <p>There are a few (equivalent) ways to phrase this assumption; two are given below.  </p> Assumption (version 1)Assumption (version 2)Applications <p>Fix a secret \\(n\\)-bit string \\(k \\in \\{0,1\\}^n\\). Let \\(\\mathcal{O}_{k,\\epsilon}\\) be an oracle that outputs independent samples \\((x_i,y_i)\\), where \\(x_i\\) is a random \\(n\\)-bit string and \\(y_i := \\langle x_i \\mid k \\rangle \\oplus e_i\\), where the bit \\(e_i\\) is 1 with probability \\(\\epsilon\\) and 0 otherwise and \\(\\langle \\cdot \\mid \\cdot \\rangle\\) means inner product. Given: \\(q\\) samples \\((x_i,y_i)\\) from \\(\\mathcal{O}_{k,\\epsilon}\\) Compute: \\(k\\) (such that \\(y_i = \\langle x_i \\mid k \\rangle \\oplus e_i\\) for all \\((x_i,y_i), i=1\\ldots q\\))</p> <p>Let \\(\\mathbf{A}\\) be a \\(q \\times n\\) matrix of (uniformly random) bits and \\(\\vec{e},\\vec{y}\\) be \\(q\\)-bit vectors (where \\(e_i = 1\\) with probability \\(\\epsilon\\) and 0 otherwise). Given: \\(\\mathbf{A},\\vec{y}\\) Compute: \\(\\vec{k} \\in \\{0,1\\}^n\\) such that \\(\\mathbf{A}\\cdot \\vec{k} + \\vec{e} = \\vec{y} \\pmod{2}\\)</p> <ul> <li>PRGs</li> <li>Perfectly binding commitment</li> <li>PAKE</li> </ul> <p></p> <p>One-way functions (OWF)</p> AssumptionApplications <ul> <li>One-time signatures (\u21d2 regular signatures)</li> </ul> <ol> <li> <p>This type of tuple is often called a \"DDH tuple\" (or a \"DDH triple\" if the generator is left out).\u00a0\u21a9</p> </li> </ol>"},{"location":"general/","title":"General","text":"Advantage The probability of an adversary violating the security property of a scheme. The advantage is generally defined with respect to a security game. For secure constructions, the adversary's advantage usually shown to be small by showing it is bounded by a negligible function. Adversary Some dishonest entity that will try to break a primitive or protocol. See Threat Models for the types of adversaries, each with different capabilities. Bijective A function which is both injective and surjective, that is, every element in the codomain has exactly one preimage in the domain. This implies that the domain and codomain have equal cardinalities (any element of the domain that doesn't map to anything is, by definition, not included in the domain).  Black-box Treating some algorithm or protocol as a \"black box\" that hides the inner mechanism, allowing only the inputs and outputs to be seen. For instance, black-box constructions are constructions that use some building block as a black box without caring about its inner workings (only its generic input-output behavior). Correctness A property of a scheme that ensures it works correctly and does not trivially meet the definition of the scheme. For example, we usually require that decryption and encryption are inverses, or that sharing and reconstruction are inverses. Cryptographic Primitives Basic building blocks for cryptographic protocols. Deterministic A function that always proceeds in the same way when run on the same outputs. Alternatively, the inputs directly determine the output. Compare to randomized. Feasibility result Field A set of elements F with two binary operations + and \u2022 (addition and multiplication) that satisfy a set of properties called the field axioms (specifically associativity, commutativity, identity, and invertibility of both operations along with distributivity of multiplication over addition). Both the rational numbers and the real numbers are fields. Functionality A particular set of capabilities or properties to be achieved. For example, many protocols exist that implement the functionality of public key encryption. In this way, a functionality is abstract and independent of implementation details, and cryptosystems are build to achieve a functionality. Often, to prove security, a protocol is compared to an ideal functionality, to show that it meets the same security properties. Function A mathematical object that maps each input to at most one output.  Group A set of elements \\(G\\) with some binary operation \u2022 (the group operation) that satisfies a set of properties called the group axioms (specifically associativity, identity, and invertibility). The integers form a group under addition. Hardness assumption A problem, such as factoring, which is assumed to be hard. A cryptographic scheme's security may hinge on the adversary not being able to solve this problem, and if the assumption turns out not to hold, the proof of security is invalidated. See Assumptions for more details. Independent and identically distributed (i.i.d.) Two random variables are i.i.d. if they have the same probability distribution and are independent of each other. Indistinguishable <p>Indistinguishability refers to how hard two probability distributions are to tell apart.  </p> Perfectly indistinguishable Two distributions are perfectly indistinguishable if they are identical: they are the same distribution. Statistically indistinguishable Two distributions are statistically indistinguishable if they are statistically \"close\", ...  Computationally indistinguishable Two distributions are computationally indistinguishable if distinguishing them would require solving some computationally intractable problem. Injective A function such that every element of the codomain is the image of at most one element of the domain. Equivalently, \\(f(a)=f(b)\\) implies \\(a=b\\).Also known as one-to-one. Compare to surjective, bijective.  Linear operations Addition and scalar multiplication. Min-entropy Negligible function A function that asymptotically (i.e. after some fixed point) decreases faster than any inverse polynomial: <p>Formal Definition</p> <p>A function \\(f\\) is negligible if for all natural numbers c, there exists a natural number \\(N\\) such that \\(f(n) &lt; n^{-c}\\) for all \\(n &gt; N\\).</p> Norm <p>A function from a vector space to non-negative (real) numbers. In cryptography, we mostly deal with integers, so norms usually map an integer vector to a single non-negative integer. A norm can be thought of as a sort of distance measure because it must meet the following three properties:  </p> <ol> <li>Triangle inequality, i.e., \\(\\mathsf{norm}(\\vec{x} + \\vec{y}) \\leq \\mathsf{norm}(\\vec{x}) + \\mathsf{norm}(\\vec{y})\\) </li> <li>Linearity up to absolute value (absolute homogeneity), i.e., \\(\\mathsf{norm}(s\\vec{x}) = \\lvert s \\rvert \\mathsf{norm}(\\vec{x})\\) for any scalar \\(s\\)</li> <li>Zero only at the origin, i.e., \\(\\mathsf{norm}(\\vec{x}) = 0\\) iff \\(\\vec{x} = \\vec{0}\\)</li> </ol> <p>Some common norms applied to a vector \\(\\vec{x} = (x_1, \\dots, x_\\ell)\\) are:</p> <ul> <li>Infinity norm: \\(\\lVert \\vec{x} \\rVert_\\infty = \\max(\\lvert x_i \\rvert)\\)</li> <li>Euclidean norm (aka L2 norm): \\(\\lVert \\vec{x} \\rVert_2 = \\sqrt{\\sum_i x_i^2}\\)</li> <li>L1 norm: \\(\\lVert \\vec{x} \\rVert_1 = \\sum_i \\lvert x_i \\rvert\\)</li> </ul> <p>These are special cases of the Lp norm \\(\\lVert \\vec{x} \\rVert_p = (\\sum_i \\lvert x_i \\rvert^p)^{1/p}\\).</p> Parameterized Probabilistic polynomial time (PPT) A potentially probabilistic algorithm that runs in polynomially many steps. In cryptography, we usually consider PPT adversaries (polynomial in the security parameter). Protocol A sequence of messages exchanged between parties to compute some functionality. A protocol specifies how parties should compute their messages based on their knowledge and the other parties' responses. Often denoted by the variable \\(\\Pi\\). Probabilistic Randomized A function whose output is influenced by some additional source of randomness. Running the function twice on the same inputs may result in a different outcome. Compare to deterministic. Ring Security game A game is a challenge in which an attacker (called the adversary and usually denoted by a curly letter \\(\\mathcal{A}\\)) is given some information and tries to break the security property of the scheme. \\(\\mathcal{A}\\) \"wins\" the game if it can give an answer that proves it broke the security property of the scheme. For an example, see the CPA-security game. See also Game-based proofs. A security game is sometimes also called an experiment. Security parameter Denoted by \\(\\lambda\\) (or sometimes \\(\\kappa\\)), this is a measure of how hard it is to break the security of a system.  Generally, an adversary's advantage in attacking a scheme should be negligible in the security parameter; thus, the parameter needs to be large enough that the specific negligible function also corresponds to a sufficiently low success probability in practice. Computational security parameters are generally \\(\\lambda = 128\\) or \\(\\lambda = 256\\) and correspond to the size of the instance of the computational problem to be solved; information-theoretic security parameters can be lower and correspond directly to an adversary's statistical success probability. (See also the Wikipedia page.) Surjective A function such that every element of the codomain has at least one preimage in the domain. Also known as onto. Compare to injective, bijective.  Sybil attack Attack in which an adversary creates multiple fake identities (parties) it controls in order to increase its influence in a network. To an outside observer these machines can't be distinguished from other honest parties/identities. One way to prevent this is asking new users to perform a somewhat costly registration process as a way to rate-limit creating new identities. Uniform A distribution is uniform, or a value uniformly distributed, if every outcome is equally likely. We may say that a value is \"drawn uniformly at random\". A uniform distribution over \\(N\\) elements means each of the elements is drawn with probability \\(1/N\\). Unary Compared to binary, which represents numbers using two symbols (0 and 1), the unary representation of a number consists only of 1s. Specifically, a number \\(n\\) is represented in unary as a string of \\(n\\) 1s (e.g., 5 in unary would be 11111). Security parameters are usually given as an input in their unary representation, i.e. \\(1^\\lambda\\). \"Without loss of generality\" This means that only one particular case is analyzed, but the argument holds equally in the other cases."},{"location":"general/#complexity-theory","title":"Complexity Theory","text":"Big-O notation Written \\(O(g(n))\\) for some function \\(g\\), this is an upper bound on the computational complexity of an algorithm/protocol/etc. when \\(n\\) is large enough (i.e., an asymptotic bound). Put another way, \\(f(n) \\in O(g(n))\\) means \\(f(n)\\) grows asymptotically no faster than \\(g(n)\\). Big-omega notation Written \\(\\Omega(g(n))\\) for some function \\(g\\), this is a lower bound on the computational complexity of an algorithm/protocol/etc. when \\(n\\) is large enough (i.e., an asymptotic bound). Put another way, \\(f(n) \\in \\Omega(g(n))\\) means \\(f(n)\\) grows asymptotically no slower than \\(g(n)\\). Big-theta notation Written \\(\\Theta(g(n))\\) for some function \\(g\\), this is an approximation of the computational complexity of an algorithm/protocol/etc. when \\(n\\) is large enough (i.e., an asymptotic bound). Put another way, \\(f(n) \\in \\Theta(g(n))\\) means \\(f(n)\\) grows asymptotically at the same rate as \\(g(n)\\). Note: \\(f(n) \\in \\Theta(g(n)) \\iff f(n) \\in O(g(n))\\) and \\(f(n) \\in \\Omega(g(n))\\). <p>Further Reading</p> <p>Khan Academy has good explanations of the concepts of Big-O, Big-Omega, and Big-Theta, and the diagrams and wording here are based on those pages and a nice summary comment by the user Cameron.</p> Polylog(n) Polynomial in the logarithm, i.e. \\(poly(\\log(n))\\)."},{"location":"general/#complexity-classes","title":"Complexity Classes","text":"P The class of decision problems (i.e., decide if \\(x\\) is an instance of some language \\(L\\); see also ZK background) solvable in polynomial time by a Turing machine. Put another way, this is the class of decision problems solvable by a uniform family of polynomial-size Boolean circuits<sup>1</sup>. P/poly Same as the class \\(P\\) except that the Turing machine is allowed a trusted \"advice string\" of size \\(O(poly(n))\\), where \\(n\\) is the size of the input. This is also known as the non-uniform version of \\(P\\), since the Turing machine can depend on the specific instance in question and can therefore vary widely between instances (modeled by using the advice string to inform the Turing machine's layout). PPAD NC <p>\"Nick's Class.\" \\(NC^i\\) is the class of decision problems solvable by a uniform family of poly-size Boolean circuits (so far, same as \\(P\\)) of depth \\(O(log^{i}(n))\\) and fan-in 2. (Therefore, \\(NC^0\\) is the class of decision problems solvable by constant-depth bounded fan-in circuits.) Then \\(NC\\) is the union of \\(NC^i\\) over all \\(i \\geq 0\\).  </p> <p>It is known that \\(NC \\subseteq P\\).</p> NP TC\\(^0\\) <p>The class of decision problems solvable by poly-size constant-depth circuits with unbounded fan-in using AND, OR, NOT, and threshold gates.  </p> <p>It is known that \\(TC^0 \\subseteq NC^1\\).</p> <p>Further Reading</p> <p>Many more complexity classes can be found on the Complexity Zoo wiki.</p>"},{"location":"general/#composition","title":"Composition","text":"Concurrent composition Two protocols \\(\\Pi_1, \\Pi_2\\) running concurrently are run with their messages arbitrarily interleaved. In the two-party case:  In general, concurrent composition of secure protocols does not maintain security (against malicious adversaries). A special case of concurrent composition is parallel composition. Compare to sequential composition. Parallel composition Two protocols \\(\\Pi_1, \\Pi_2\\) running in parallel run in \"lockstep\", i.e. the first round messages of both are sent together, followed by the second, and so on. In the two-party case:  In general, composing secure protocols in parallel does not maintain security (against malicious adversaries). Parallel composition is a special case of concurrent composition. Compare to sequential composition. Hybrid composition <p>Composition Theorem</p> <p>If \\(\\rho_1, \\ldots, \\rho_m\\) are secure protocols for computing the functionalities \\(f_1, \\ldots, f_m\\), and if \\(\\Pi\\) is a secure protocol for computing \\(f\\) in the \\((f_1, \\ldots, f_m)\\)-hybrid world, then the composed protocol \\(\\Pi^{\\rho_1, \\ldots, \\rho_m}\\) is a secure protocol for \\(f\\). That is, if we have a protocol that can secure compute some function \\(f\\) given it has access to some other functionality/ies, and we have protocols for securely computing those functionality/ies, we can \"plug in\" those protocols into our main protocol and it will be secure.</p> Sequential composition Two protocols are composed sequentially when they are run back-to-back, i.e. one protocol only begins after the other has concluded. In the two-party case:  Sequential composition of two secure protocols is still secure! Compare to concurrent composition, parallel composition."},{"location":"general/#threat-models","title":"Threat Models","text":"Malicious adversary <p>An adversary that can deviate arbitrarily from the protocol it is participating in. That is, it doesn't follow the rules and may send malformed, empty, or incorrect messages, not send a message when it is supposed to or vice versa, and otherwise behave maliciously. Also known as active adversary; compare to semi-honest adversary.</p> <p>Notation</p> <p>We sometimes use * as a superscript to denote that a party may be malicious, i.e. cheat and deviate from the protocol. For instance, the party \\(S^*\\) in a commitment scheme denotes a potentially malicious sender.</p> Semi-honest adversary An adversary that follows the protocol and acts honestly, but tries to learn as much as possible from the information it sees. Also known as honest-but-curious (HbC) or passive. <p>Less standard threat models</p> <p>The following threat models are newer and thus less widely used than the ones until now. It's possible different papers use different terms for them or that the names will change in the future.</p> Fail-stop adversary Slightly stronger than the semi-honest adversary; follows the protocol the way a semi-honest adversary does, but can choose to abort at any time (or cause parties it controls to abort). Semi-malicious adversary Lies between the semi-honest and malicious cases. The adversary must follow the protocol, but it can arbitrarily and adaptively choose the inputs and randomness used in the protocol. See [BHP17 \u00a74]; introduced by [AJL+12 \u00a75]. Uniform adversary A uniform adversary uses the same strategy regardless of the protocol instance. Compare to non-uniform adversary."},{"location":"general/#security-definitions-notions","title":"Security Definitions &amp; Notions","text":"Adaptive security Secure against an adaptive adversary, which can choose its actions dynamically and based on the responses of a game/protocol/etc. In particular, in multi-party protocols, it can choose which parties to corrupt during the course of the protocol (based on the messages they send) instead of fixing a set upfront. This is also called full security. Computational security The security of the scheme can be reduced to solving some problem that is assumed to be computationally hard, i.e. its security rests on a computational assumption. Covert security Forward secrecy In key agreement protocols, this is the guarantee that the compromise of long-term secrets in some session \\(t\\) does not affect the security of any sessions that took place before \\(t\\) (i.e., those messages still cannot be decrypted). This also implies that the compromise of the session key for \\(t\\) does not expose previous sessions. Information-theoretic security ... See also unconditional security. Perfect security Security is absolute, for example based on two distibutions which are perfectly indistinguishable. Selective security In this case, the adversary must pick (select) its messages/queries upfront. Also called non-adaptive or static security. Compare to adaptive security. Statistical security Another term for information-theoretic security. UC security Security in the \"universal composability\" framework. This is a simulation-based security notion; schemes which are proven UC-secure are guaranteed to maintain their security properties even under arbitrary composition. Unconditional security Usually used interchangeably with information-theoretic security. However, it can also be used to mean security that is not based on any computational assumption."},{"location":"general/#models","title":"Models","text":"<p>Notation</p> <p>The phrase used is \"<code>Scheme</code> is secure in the <code>X</code> model\". </p> Oracle Algebraic Group Model (AGM) This is a stronger assumption than the standard model, but weaker than the GGM. The model assumes that the adversary is an algebraic adversary, meaning that for any group element it outputs, it also knows its representation in the group. This differs from the GGM because the adversary knows and can exploit the group structure. Generic Group Model (GGM) This model assumes that the adversary is given access to a randomly chosen (encoding of a) group instead of the groups used in practice, which have efficient encodings. The adversary also has access to an oracle for the group function. (This is like how, in the random oracle model, we give the adversary access to a random oracle instead of a real hash function used in practice.) Quantum Random Oracle Model (QROM) An analogue of the ROM for quantum adversaries. Random Oracle Model (ROM) A proof paradigm that models hash functions as random oracles, i.e. an oracle that outputs a random number for any input (but outputs the same number when given the same input). Read more here. Variants include the programmable ROM and others. Standard Model This model assumes only that the adversary is limited by time or computational power; it makes no further assumptions (the way, e.g., the ROM does). Proofs in the standard model therefore usually rest on a computational hardness assumption, but no idealized cryptographic primitives, and are thus very difficult. In this way this model is \"better\" than the others listed here because it assumes less. Also known as the bare model or plain model. <ol> <li> <p>in logspace, i.e. using O(log(n)) memory.\u00a0\u21a9</p> </li> </ol>"},{"location":"notation/","title":"Standard Notation","text":"\\(:=\\) Used to declare/initialize the contents of a variable (unless they are output by an algorithm, in which case we use \\(\\gets\\)), e.g., \\(y := g^x\\) \\(\\gets\\) Initialize the contents of a variable to the output of an algorithm. e.g., \\(c \\gets \\mathsf{Enc}(pk, x)\\). \\(\\stackrel{\\$}{\\gets}\\) or \\(\\stackrel{R}{\\gets}\\) sample uniformly at random. For example, \\(x \\stackrel{\\$}{\\gets} \\mathcal{X}\\) means to sample \\(x\\) uniformly at random from the set (or distribution) \\(\\mathcal{X}\\). \\(\\{0,1\\}^*\\) and \\(\\{0,1\\}^n\\) The set of binary strings of arbitrary length and length \\(n\\), respectively. \\([n]\\) The set of integers \\(\\{1, 2, \\dots, n\\}\\). \\(\\mathcal{A}\\) Adversary \\(\\mathbb{G}\\) A group i.i.d. Independent and identically distributed \\(\\mathsf{td}\\) Trapdoor w.h.p. With high probability. \\(\\mathbb{Z}_n\\) The additive group of integers modulo \\(n\\), namely \\(\\{0,\\dots,n-1\\}\\). This is a cyclic group, and in fact also a ring). When \\(n\\) is a prime \\(p\\), all non-identity elements are generators of the group. In that case, the set is also a finite field (since all nonzero elements have multiplicative inverses).  \\(\\mathbb{Z}_n^\\times\\) or \\(\\mathbb{Z}_n^*\\) The multiplicative subgroup of \\(\\mathbb{Z}_n\\), which consists of all elements of \\(\\mathbb{Z}_n\\) that are coprime with \\(n\\). This means that they all have multiplicative inverses modulo \\(n\\) and thus this group is a commutative multiplicative group. By the definition of Euler's totient function, this means that the order of the group is \\(\\lvert \\mathbb{Z}_n^* \\rvert = \\phi(n)\\). When \\(n\\) is a prime \\(p\\), \\(\\lvert \\mathbb{Z}_p^* \\rvert = \\phi(p) = p-1\\) is not prime (for \\(p&gt;3\\)). Thus, computing the order of any element in the group is efficient if the factorization of \\(p-1\\) is known. For more number theory/algebra basics, see David Wu's factsheet."},{"location":"proofs/","title":"Security Proofs: Types and Techniques","text":"<p>Black-box versions of each of these techniques (black-box reduction, black-box simulation, etc.) are the strongest proofs. In a black-box proof, the adversary is treated as a \"black box\" (its inner workings are unknown), that is, the approach must work for any adversary. This affects the order of quantifiers in a proof (\"There exists \u27e8some technique\u27e9 such that for all adversaries, the scheme is secure\" instead of \"for all adversaries, there exists \u27e8some technique\u27e9 such that the scheme is secure\".)</p> Hybrid argument <p>Often used in game-based proofs, but a similar technique is also used to break down the various changes between the simulator in the real-world protocol in simulation-based proofs. We start with a security game, then slowly replace pieces of the game (each modified game is called a hybrid game or hybrid experiment) in a way that is induistinguishable to the adversary. Eventually we arrive at a simple game in which the adversary clearly has negligible advantage (or where this can be shown via a reduction).</p> <p>Further Reading</p> <p>\"Sequences of Games: A Tool for Taming Complexity in Security Proofs\" by Victor Shoup</p> Reduction <p>We reduce the security of some scheme Y to an assumption X, that is, we wish to show that the assumption X implies the security of scheme Y (X \u21d2 Y). </p> <p>This is done by contradiction: we instead prove the contrapositive, that if Y is insecure, X does not hold (\u00acY \u21d2 \u00acX). Specifically, we assume the existence of an adversary \\(\\mathcal{A}_1\\) that breaks the security properties of Y, and use it to construct an adversary \\(\\mathcal{A}_2\\) that can run \\(\\mathcal{A}_1\\)'s code as a subroutine to break the security of X. </p> <p>Reduction tightness</p> <p>A reduction is called tight if the running time and advantage of \\(\\mathcal{A}_2\\) is \"close to\" that of \\(\\mathcal{A}_1\\) (see here for some discussion on what is \"close\").</p>"},{"location":"proofs/#proof-by-simulation","title":"Proof by Simulation","text":"<p>Further Reading</p> <p>How to Simulate It \u2013 A Tutorial on the Simulation Proof Technique by Yehuda Lindell</p> Rewinding When a simulator \"rewinds\" the adversary to a previous step in its execution. A good way to think about this is to remember that the adversary is a (usually PPT) algorithm, and even if it is probabilstic the randomness can be programmed as an input. This means that the simulator can just re-run \\(\\mathcal{A}\\) with the same inputs up until a certain point, when it can \"branch\" from the previous run and try a new response. An example is the proof of knowledge soundness of a Sigma protocol.  A simulator which does not use rewinding is called a straight-line."},{"location":"proofs/#universal-composability-uc-framework","title":"Universal Composability (UC) Framework","text":"<p>Introduced by [Canetti'01].</p>"},{"location":"techniques/","title":"Standard Techniques","text":"Fiat-Shamir (FS) Transform A technique which turns any constant-round public-coin HVZK protocol (e.g., a sigma protocol) into a non-interactive zero-knowledge proof of knowledge (NIZK PoK) in the random oracle model. Introduced in [FS86]. The technique works as follows: instead of sampling a random challenge, set the challenge equal to the hash of the protocol transcript until that point. Fujisaki-Okamoto (FO) Transform The FO transform is a technique which \"upgrades\" a CPA-secure<sup>1</sup> PKE to CCA-security in the random oracle model. Introduced in [FO99]. Given the base scheme \\(\\Pi_E = (\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})\\) and two hash functions \\(H_1, H_2\\) modeled as random oracles, the FO-transformed ciphertext for a message \\(m\\) is \\((\\mathsf{Enc}(\\mathsf{pk}, r; H_1(r)), H_2(r) + m)\\), where \\(r\\) is sampled uniformly at random. Complexity Leveraging Forking Lemma Leftover Hash Lemma (LHL) Union bound Naor-Yung Paradigm <p>Another way to \"upgrade\" a CPA-secure encryption scheme \\(\\Pi_E = (\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})\\) to a CCA1 one using an adaptively-secure NIZK: compute \\(c_1 \\gets \\mathsf{Enc}(pk_1, m)\\) and \\(c_2 \\gets \\mathsf{Enc}(pk_2, m)\\) and use the NIZK to prove \\(c_1, c_2\\) encrypt the same message; the CCA-secure ciphertext is \\((c_1, c_2, \\pi)\\).</p> <p>Further Reading</p> <p>\"CMSC 858K \u2014 Advanced Topics in Cryptography: Lecture 7\" by Jonathan Katz</p> <ol> <li> <p>In fact, the base scheme only needs to satisfy an even weaker security property than CPA-security.\u00a0\u21a9</p> </li> </ol>"},{"location":"Areas-of-Cryptography/blockchain/","title":"Blockchain and Cryptocurrencies","text":"<p>Background Reading</p> <p>Bitcoin whitepaper (2009): A Peer-to-Peer Electronic Cash System by Satoshi Nakamoto Ethereum whitepaper (2014):  Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform by Vitalik Buterin  </p> <p>The Blockchain Trilemma</p> <p>The Blockchain Trilemma refers to the idea that no blockchain can have all three of the following: security, scalability, and decentralization. Any blockchain is forced to optimize for two features to the detriment of the third. The term was coined by Ethereum founder Vitalik Buterin.</p>"},{"location":"Areas-of-Cryptography/blockchain/#layer-1-consensus","title":"Layer 1 (Consensus)","text":"<p>Summary</p> <p>An area of problems about how to get distributed systems to agree on state or some other piece of information. Found new application with the emergence of blockchains.</p> State Machine Replication (SMR) The problem of ensuring that a group of machines maintains agreement on a collective state even under updates (which may only be sent to some of the machines) Byzantine Agreement (BA) <ul> <li>Consistency: All honest parties output the same bit</li> <li>Validity: If all honest parties input \\(b\\), all honest parties will output \\(b\\)</li> <li>Termination: All honest parties eventually terminate and output some value</li> </ul>"},{"location":"Areas-of-Cryptography/blockchain/#state-representation","title":"State Representation","text":"<p>There are two main accounting models used to represent the state of a blockchain system:</p> UTXO Unspent Transaction Output. Every transaction tx consists of input transactions and output transactions; before executing tx, the chain (miners) check that the input transactions are unspent, i.e., they are as-yet unused output transactions from some previous tx' (they are in the UTXO set). Once tx is processed its inputs are removed from the UTXO set. That means that there is a directed acyclic graph (DAG) describing how assets (UTXOs) have moved between addresses. This DAG represents the global state. (Account balances are computed locally by adding up an account's UTXOs.) Used by: Bitcoin, Litecoin, and Monero. Account-based The account model simply maintains a database mapping accounts to balances. This database represents the global state. Used by: Ethereum. <p>Further Reading</p> <p>The UTXO vs. Account Model</p>"},{"location":"Areas-of-Cryptography/blockchain/#layer-2","title":"Layer 2","text":"<p>Summary</p> <p>Layer 2 protocols are protocols which rely on an underlying \"main\" chain and are meant to help with scalability.</p> Payment channel (PC) ** Payment channel network (PCN)** Sidechain Rollup  These are often erroneously called \"zk\" even though they are not zero-knowledge."},{"location":"Areas-of-Cryptography/blockchain/#layer-3-ui","title":"Layer 3 (UI)","text":"Deterministic wallet A deterministic wallet is a cryptocurrency wallet where the keys are deterministically dervied from some seed (e.g., a string of words written on a piece of paper). If the user loses their keys, they can re-derive them from the seed."},{"location":"Areas-of-Cryptography/ecc/","title":"Elliptic-Curve Cryptography","text":"<p>Further Reading</p> <ul> <li>\"A (Relatively Easy To Understand) Primer on Elliptic Curve Cryptography\" by Nick Sullivan</li> <li>\"Elliptic Curve Cryptography: a gentle introduction\" by Andrea Corbellini</li> </ul> <p> </p> Elliptic curve (EC) <p>In cryptography, we use ECs over finite fields (i.e., \\(\\mathbb{F}_n\\), which is unique for a given value of \\(n\\)). Often, we use a prime field \\(\\mathbb{F}_p\\) where \\(p\\) is prime. An EC over \\(\\mathbb{F}_n\\) is defined as a set of points \\((x,y) \\in \\mathbb{F}_n^2\\) satisfying some bivariate equation. The points form a group.</p> Type Field EC Examples Weierstrass \\(\\mathbb{F}_p\\) \\(\\{ (x,y): y^2 = x^3 + ax + b, 4a^3 + 27b^2 \\neq 0\\}\\) All curves can be written in Weierstrass form Koblitz \\(\\mathbb{F}_{2^p}\\) \\(\\{ (x,y) : y^2 + xy = x^3 + ax^2 + 1, a \\in \\{0,1\\}\\}\\) nistk163, nistk283, nistk571 (the number after <code>k</code> is the prime \\(p\\)) Binary \\(\\mathbb{F}_{2^m}\\) \\(\\{ (x,y) : x^2 + xy = x^3 + x^2 + b \\}\\) nistb163, nistb283, nistb571 Edwards \\(\\{ (x,y) : x^2 + y^2 = 1 + dx^2y^2, d \\in \\{0,1\\}\\}\\) Montgomery \\(\\{ (x,y) : by^2 = x^3 + ax^2 + x, b(a^2-4) \\neq 0 \\}\\) Curve25519 <p>An EC may or may not be pairing-friendly. Pairing-friendly curves have all three of the common pairings (Weil, Ate, and Tate; see below).</p> <ul> <li>Pairing-friendly curves: Baretto-Naehrig (e.g., BN254), Barreto-Lynn-Scott (e.g., BLS12-381, BLS12-377), Kachisa-Schaefer-Scott (KSS), Miyaji-Nakabayashi-Takano (MNT)</li> <li>Pairing-free curves: secp256k1, NIST P-256, Curve25519</li> </ul> <p>Resource</p> <ul> <li>The parameters for many elliptic curves used in practice can be found here.</li> </ul>"},{"location":"Areas-of-Cryptography/ecc/#pairing-based-cryptography","title":"Pairing-Based Cryptography","text":"(Bilinear) Pairing <p>In its most common form in cryptography, a bilinear pairing is a map \\(e: G_1 \\times G_2 \\rightarrow G_T\\), where \\(G_1, G_2\\) are additive cyclic groups of prime order \\(q\\) and \\(G_T\\) is a multiplicative cyclic group of order \\(q\\). The map \\(e\\) is required to have the following properties:</p> <ul> <li>Bilinearity. For any \\(a,b \\in \\mathbb{F}_q^*\\) and \\(P, P_1, P_2 \\in G_1\\) and \\(Q, Q_1, Q_2 \\in G_2\\),<ul> <li>\\(e(aP, Q) = e(P, aQ) = e(P,Q)^a\\)<sup>3</sup> and</li> <li>\\(e(P_1 + P_2, Q) = e(P_1, Q) \\cdot e(P_2, Q)\\) and \\(e(P, Q_1 + Q_2) = e(P, Q_1) \\cdot e(P, Q_2)\\).</li> </ul> </li> <li>Non-degeneracy. \\(e(P, Q) \\neq 1\\) where \\(P, Q\\) are generators of \\(G_1, G_2\\), respectively.</li> <li>Computability. There is an efficient algorithm for computing \\(e\\).</li> </ul> <p>(A bilinear map is only required to meet the first property.)</p> <p>Examples: Weil pairing, Tate pairing, Ate pairing</p> <p>Depending on the (sub)group (i.e., elliptic curve) used, a pairing falls into one of three types:</p> <ul> <li>Type-1<sup>1</sup> (symmetric pairing): \\(G_1 = G_2\\). DDH is easy in \\(G_1\\) (and therefore \\(G_2\\)).</li> <li>Type-2<sup>2</sup>: \\(G_1 \\neq G_2\\) but there exists an efficiently computable homomorphism \\(\\phi: G_2 \\rightarrow G_1\\). DDH is easy in \\(G_2\\) but thought to be hard in \\(G_1\\), referred to as the external Diffie-Hellman (XDH) assumption. Examples: Some pairings on BN curves</li> <li>Type-3: \\(G_1 \\neq G_2\\) and there is no efficiently computable homomorphism between \\(G_1\\) and \\(G_2\\). DDH is thought to be hard in both \\(G_1\\) and \\(G_2\\), referred to as the symmetric external Diffie-Hellman (SXDH) assumption. Examples: BLS curves, some pairings on BN curves</li> </ul> <ol> <li> <p>Type-1 pairings are generally less efficient to compute than asymmetric (type-2 and 3) pairings, so they are less commonly used.\u00a0\u21a9</p> </li> <li> <p>Type-2 pairings have been found to be less functional, secure, and efficient than type-3, so they are hardly used anymore.\u00a0\u21a9</p> </li> <li> <p>Therefore \\(e(aP, bQ) = e(P,Q)^{ab}\\).\u00a0\u21a9</p> </li> </ol>"},{"location":"Areas-of-Cryptography/mpc/","title":"Multi-Party Computation (MPC)","text":"<p>Summary</p> <p>Functionality in which two or more parties with secret inputs compute a joint function on those inputs. No party learns any more information about the others' inputs, except what it can infer from the output. </p> <p>Sometimes also referred to as secure multi-party computation (SMC), multi-party computation (MPC) is a functionality in which two or more parties with secret inputs want to compute a joint function \\(f\\) on those inputs. More explicitly, for N parties with inputs \\(x_1, \\ldots, x_N\\), an MPC protocol takes those inputs and outputs \\(y := f(x_1, \\ldots, x_N)\\).</p> <p>The protocol should meet a couple of conditions to be interesting/useful:</p> <ul> <li>Security. None of the parties learn anything about the other parties' inputs (except what they can deduce from the output)</li> <li>Correctness. \\(y\\) should be correct. That is, \\(y\\) should in fact be the function \\(f\\) applied to the parties' inputs \u2013 no errors.</li> </ul> <p>Why is this useful? A simple example is Yao's Millionaries' Problem. </p> <p>Example</p> <p>Two millionaires want to know who's richer, but they don't want to reveal exactly how rich they are. They can run an MPC protocol where the inputs are their net worths and the function \\(f\\) computes the sign of \\(x_1 - x_2\\). \\(f\\) could be defined as</p> \\[f(x_1, x_2) = \\begin{cases} 1   &amp; x_1 &gt; x_2\\\\ 0   &amp; x_1 = x_2\\\\ -1  &amp; x_1 &lt; x_2 \\end{cases}\\] <p>There are more serious real-world applications for this too. You could imagine using this to let hospitals collaborate on health analytics without sharing their patient records and other similar use cases.</p>"},{"location":"Areas-of-Cryptography/mpc/#building-blocks","title":"Building Blocks","text":"Beaver Triples For any variable \\(d\\), let \\([d]\\) denote a party's share of \\(d\\). Assuming parties hold secret shares of values \\(x,y,a,b,c=ab\\) for uniform \\(a,b\\), they can compute shares of \\(z=xy\\) as follows: <ol> <li>Publicly reconstruct \\(x-a, y-b\\):<ul> <li>Locally compute shares of \\(x-a, y-b\\)</li> <li>Broadcast shares to reconstruct</li> </ul> </li> <li>Use local computation to get shares of \\(z\\):<ul> <li>Each party sets its share \\([z] = [c] + (y-b)[x] + (x-a)[y] - (x-a)(y-b)\\)</li> <li>Note that these are shares of \\(xy\\)!</li> </ul> </li> </ol> Cut-and-choose This is an idea used to turn a semi-honest MPC protocol into a malicious-secure one. Whenever we rely on the well-formedness of some (potentially malicious) party's inputs, we use the following idea to guarantee their well-formedness: we ask the party to generate many values, then challenge it on a randomly selected fraction of them. The party opens this subset, and if they are all well-formed/honestly generated, the unopened half is used in the protocol. By a statistical argument, these are very likely also well-formed. Oblivious Transfer (OT) <p>Functionality in which one party holds two strings and the other a selection bit b. The second party learns the string corresponding to its selection bit and nothing more, while the first party learns nothing about the selection bit.  OTs with different numbers exist, such as 1-out-of-4 OT (\\(P_2\\) selects one of four choices) or more generally 1-out-of-\\(n\\) OT for some parameter \\(n\\).</p> <p>Construction: Naor-Pinkas OT</p> Construction Secret-sharing <p>Splitting a secret between parties so that none of the parties know the secret, but they each have a piece of the information, and if they work together they can recover the secret. Here's a visual intuition:  Some classic schemes are:</p> <p>Exclusive OR (XOR, \\(\\oplus\\)) secret-sharing</p> <p>For a secret \\(s\\), set Party \\(i\\)'s share to some random value \\(r_i\\), except for a designated party which gets \\(s \\oplus r_1 \\oplus \\ldots \\oplus r_N\\). The shares XOR together to \\(s\\), but each individual share looks random.</p> <p>Shamir secret sharing</p> <p>This is a form of \\((t+1)\\)-out-of-\\(n\\) secret-sharing, i.e., at least \\(t+1\\) out of \\(n\\) parties must work together to recover the secret. Shamir secret-sharing gives every party a point on a degree-t polynomial. Because t+1 points define a unique polynomial, t+1 parties can work together to recover it. The secret is the value when the polynomial is evaluated at 0. Interactive demo here.</p> <p>Secret-sharing schemes with additional properties also exist and are sometimes helpful for constructing MPC.</p> <ul> <li>Function secret sharing (FSS):</li> <li>Homomorphic secret sharing (HSS):</li> <li>Robust secret sharing: Does not consider a corrupt dealer. ...</li> <li> <p>Verifiable secret sharing (VSS): Protects against a corrupt dealer. Parties who receive shares from the dealer can also run a verification function to confirm that the shares they received are well-formed (are consistent with each other).</p> <p>Feldman VSS [Fel87]</p> ConstructionProperties <p>Choose a DLog-hard subgroup \\(G\\) of \\(\\mathbb{Z}_p\\) such that \\(G\\) is of order \\(q\\) with generator \\(g\\). The dealer shares the secret \\(s\\) as in regular Shamir secret sharing, using some degree-t polynomial \\(P(x) = s + a_1 x + \\ldots + a_t x^t \\pmod{q}\\).</p> <p>For verifiability, the dealer includes commitments to the coefficients of \\(P\\), calculated as </p> \\[c_0 := g^s, c_1 := g^{a_1}, \\ldots, c_t := g^{a_t} \\in \\mathbb{Z}_p\\] <p>To verify that some share \\(sh = P(i)\\), party \\(i\\) (working in \\(\\mathbb{Z}_p\\)) checks that</p> \\[ g^{sh} =^? c_0 c_1^i \\cdots c_t^{i^t} \\pmod{p}\\] <p>Note that if the share and the commitments are well-formed, this equals \\(g^{s + a_1 i + \\ldots + a_t i^t} = g^{P(i)}\\).</p> <ul> <li>Computationally secure (by DLog assumption)</li> </ul> </li> </ul>"},{"location":"Areas-of-Cryptography/mpc/#protocol-parameters","title":"Protocol Parameters","text":"Communication complexity The amount of data (the size of the messages) exchanged between parties in the protocol. This lower bounds the bandwidth required to run the protocol. Corruption type Semi-honest, malicious, etc. Corruption threshold (\\(t\\)) Honest majority (\\(t &lt; n/2\\)), dishonest majority (\\(t &lt; n\\)), etc. Hardness assumptions The computational hardness assumption(s) underlying the security of the protocol. Round complexity <p>The number of rounds in the protocol. This lower bounds the time required to complete the protocol.</p> <p>Info</p> <p>The optimal round complexity of an MPC protocol is 2 rounds, since every party needs to send some information about its inputs and then receive some response based on that from the other parties. </p> Trusted setup"},{"location":"Areas-of-Cryptography/mpc/#security-guarantees","title":"Security guarantees","text":"Fairness Either all parties learn the output, or no party does. Put in other words, the malicious party/ies cannot learn the output without also revealing it to all honest parties. Guaranteed output delivery (GOD) The strongest type of correctness guarantee. In a protocol with GOD, an adversary cannot even carry out a denial-of-service attack; the (correct) output will always be learned by the participants.   Identifiable abort If the protocol fails, the honest parties learn which corrupted party was the cause. Security with abort The protocol is secure, but an adversary can still cause it to abort."},{"location":"Areas-of-Cryptography/mpc/#generic-protocols","title":"Generic Protocols","text":"<p>These are MPC protocols that work for any function. Most protocols turn the function to be computed into a circuit representation (yes, like in electrical engineering with AND gates and whatnot). </p> Yao's Garbled Circuits (GC) <p>One party (the garbler) \"garbles\" the circuit by successively encrypting wire keys. The other party (the evaluator) follows the path of correct decriptions through the circuit until it obtains the keys corresponding to the output value. [Original paper]</p> <p>Building blocks: Secure OT Optimizations: Point-and-permute, PRF for encryption, garbled row reduction, half-gates, free XOR.</p> Goldreich\u2013Micali\u2013Wigderson (GMW) (semi-honest version) <p>Construct gates so that parties can step through the circuit using XOR-shares of wires. Multiplication gates require 1-out-of-4 OT to communicate the correct output shares.  </p> <p>Building blocks: Secure OT</p> Goldreich\u2013Micali\u2013Wigderson (GMW) (malicious version) <p>Same as semi-honest, but use zero-knowledge proofs to ensure well-formedness.  </p> <p>Building blocks: Secure OT, ZKPs</p> Ben-Or\u2013Goldwasser\u2013Wigderson (BGW) <p>Same structure as GMW but over arithmetic circuits (where wires carry field elements). So, instead of using XOR-shares, use \\((t+1)\\)-out-of-\\(n\\) Shamir secret-sharing. Multiplication gates use a degree-reduction step to maintain the invariant that parties hold well-formed wire value shares. [full proof]</p> <p>Assumptions: None!</p> Chaum\u2013Crepeau\u2013Damg\u00e5rd (CCD) Beaver\u2013Micali\u2013Rogaway (BMR) <p>This can be viewed as an adaptation of Yao's garbled circuit approach to more than two parties while keeping its low round complexity. The idea is to use GMW to compute a garbled circuit for the function to be evaluated; then, one party evaluates the garbled circuit. [Original paper] [Rogaway's Thesis] [Pragmatic Introduction to MPC, Section 3.5]</p> <p>Assumptions: Secure OT</p> Cramer\u2013Damg\u00e5rd\u2013Nielsen (CDN) <p>Building blocks: Threshold homomorphic encryption</p>"},{"location":"Areas-of-Cryptography/mpc/#tabular-summary","title":"Tabular Summary","text":"<p>\\(n\\): number of circuit gates</p> <p>\\(d\\): depth of circuit  </p> Year Name Number of parties Threat Model Round Complexity Communication Complexity Circuit Representation 1986 Yao's GC 2 &lt;2 semi-honest \\(O(1)\\) \\(O(n)\\) Boolean 1987 GMW many &lt;\\(n\\) semi-honest \\(O(d)\\) \\(O(1)\\) Boolean \u200b many &lt;\\(n\\) malicious Boolean 1988 BGW many &lt;\\(n/2\\) semi-honest \\(O(d)\\) \\(O(d)\\) Arithmetic \u200b many &lt;\\(n/3\\) malicious \\(O(d)\\) Arithmetic 1988 CCD many 1990 BMR many &lt;\\(n\\) \\(O(1)\\) Boolean 2001 CDN many &lt;\\(n/2\\) malicious \\(O(d)\\) \\(O(n)\\) Arithmetic"},{"location":"Areas-of-Cryptography/mpc/#mpc-extensions","title":"MPC Extensions","text":"Non-interactive MPC (NI-MPC) Non-interactive 2PC"},{"location":"Areas-of-Cryptography/mpc/#special-purpose-mpc","title":"Special-Purpose MPC","text":"<p>When considering only a specific class of functions, we can often come up with faster protocols that are specially tailored to the problem.</p> Private set intersetion (PSI) Two parties, each with their own set, want to compute the intersection of these sets without revealing any of the elements not in the intersection. Private Information Retrieval (PIR)"},{"location":"Areas-of-Cryptography/other/","title":"Other","text":"Program Obfuscation <p>hide the inner workings (and secrets) of a program cryptographically while preserving functionality. </p> Virtual-black-box (VBB) security The strongest notion of program obfuscation; it says that the obfuscated program acts as a black box.  Indistinguishability obfuscation (iO) Usually styled as \\(\\mathcal{iO}\\).  Quantum Cryptography Rebuilding cryptographic primitives and cryptosystems that run on (and take advantage of the properties of) quantum computers. Rational Cryptography"},{"location":"Areas-of-Cryptography/pqc/","title":"Post-quantum cryptography (PQC)","text":"<p>Summary</p> <p>Cryptographic primitives that are secure against adversaries with quantum capabilities. Not to be confused with quantum cryptography, where the users of the cryptography must have quantum capabilities; in PQC, the protocol itself can still use classical computers, it's just secure against a broader class of adversaries (quantum in addition to classical adversaries).</p> Code-based cryptography Hash-based cryptography Isogeny-based cryptography Lattice-based cryptography Cryptography based on lattice hardness assumptions."},{"location":"Areas-of-Cryptography/zk/","title":"Zero-Knowledge (ZK)","text":"<p>Summary</p> <p>Ways to prove knowledge of a piece of information without revealing that information. More specifically, the goal is usually to prove knowledge of a witness for some statement in a language without revealing the witness.</p>"},{"location":"Areas-of-Cryptography/zk/#background","title":"Background","text":"<p>First, we define what an \\(NP\\) language is. A language is some set of elements that meet a particular property. For instance, the language \\(\\mathcal{L}_{HAM}\\) is the set of graphs which contain a Hamiltonian cycle. A less mathy example might be the set of words which have double-letters (\"hello\" is in this language because it contains two back-to-back L's, but \"world\" is not).</p> <p>Loosely defined, a language is in NP if it is difficult to decide whether an element belongs to a language, but easy to confirm that it is when provided some evidence (called a witness). In the case of \\(\\mathcal{L}_{HAM}\\), it's difficult to check if a graph contains a Hamiltonian cycle because finding such a cycle is hard. But if you are given a graph and a supposed cycle in the graph, it's easy to check that the graph really does contain that cycle. </p> <p>In the case of our less abstract example, think of a computer program that determes whether a word is in the double-letter language: we have to check all the pairs of consecutive letters in the word and see if any of them match. If we are told exactly which two letters repeat and where they are in the word (that is, given the witness <code>ll, 2</code> for the word \"hello\"), we can quickly jump to the letter at index <code>2</code> in the word and only check that the next two letters both equal <code>l</code>. (This is not a perfect example, since cycling through the entire length of the word doesn't take all that much time, but the point is that the witness simplifies the verification process.)</p>"},{"location":"Areas-of-Cryptography/zk/#zk_1","title":"ZK","text":"<p>Zero-knowledge (ZK) protocols occur between two parties: a prover and a verifier. The prover's goal is to convince the verifier that some statement \\(x\\) is in some language \\(\\mathcal{L}\\), by convincing the verifier that it knows some witness \\(w\\) for that statement. The verifier's goal is to be sure the prover knows such a witness.</p> <p>ZK protocols are only interesting if the prover doesn't want to reveal its witness (the zero-knowledge property). (If we didn't care about revealing the witness, the prover could simply send the witness to verifier and we'd be done.)</p> <p>Intuitive Example: Where's Waldo? in zero-knowledge</p> <p>3-coloring [GMW]</p> SchemeProperties"},{"location":"Areas-of-Cryptography/zk/#properties","title":"Properties","text":"Completeness For honest prover \\(P\\) and verifier \\(V\\), the protocol will accept only on \"correct\" (true) statements (except with negligible probability). Honest-verifier zero-knowledge (HVZK) Non-interactive No interaction is required; that is, a proof consists of a single message sent by the prover to the verifier (1 round). Soundness Intuitively, a cheating (malicious) prover \\(P^*\\) cannot (except with negligible probability) provide a valid proof of a false statement.  <ul> <li> Knowledge Soundness This property is stronger than soundness. Intuitively, it says that any valid proof has a corresponding witness. Formally, for any valid proof, there exists an extractor which can extract the witness when given the proof. What does this actually mean? It says that if a prover provides a valid proof, it must have known the witness. In other words, a cheating prover cannot provide a proof of even a true statement if it does not know the witness. </li> <li> Special Soundness This lies between soundness and knowledge soundness (?) and applies only to interactive proof systems. Given two (or \\(s\\), in the case of \\(s\\)-special soundness) valid transcripts for the same statement and with the same first message, there exists an efficient extractor which can recover the witness corresponding to the statement. The \"special\" part means that this property implies soundness. </li> <li> Simulation Soundness This property requires that soundness holds even when \\(P^*\\) has seen many simulated proofs (potentially even for false statements), i.e. \\(P^*\\) is additionally given an arbitrary number of statement-proof pairs \\((x,\\pi)\\) such that \\(V(x,\\pi)=1\\). </li> <li> Simulation Extractability aka simulation-knowledge soundness. A combination of knowledge soundness and simulation soundness, this notion says that knowledge soundness holds even when given access to arbitrarily many simulated proofs. This notion was formulated to capture the notion of non-malleability (which it implies), since knowledge soundness on its own says nothing about the capabilities of a prover that has seen a valid proof to produce a new valid proof by \"mauling\" the honest proof (malleability). A good discussion can be found in the introduction of [AB19]. </li> </ul> Succinct <ol> <li>the proof size is \"small\"</li> <li>verification is \"fast\"</li> </ol> <p>There is some disagreement on exactly how to define \"small\" and \"fast\" in the above: constant, polynomial in the security parameter, polylogarithmic in the statement size, sublinear in the witness? What exactly is meant often depends on the author.  </p> <p>\"Small\" often means polynomial in the security parameter (\\(\\lvert \\pi \\rvert \\in \\mathrm{poly}(\\lambda)\\)) or polylogarithmic in the statement size (\\(\\lvert \\pi \\rvert \\in \\mathrm{polylog}(\\lvert x \\rvert)\\)), but could be as general as sublinear in the size of the witness. \"Fast\" could mean polylogarithmic in the security parameter and statement size (\\(V(x,\\pi) \\in O(\\mathrm{polylog}(\\lambda + \\lvert x \\rvert))\\)).</p> Witness indistinguishable (WI) Given a proof, the (malicious?) verifier cannot distinguish between which of two valid witnesses was used to generate the proof with more than negligible probability. Zero-knowledge (ZK) (With overwhelming probability,) a malicious verifier \\(V^*\\) learns nothing about the prover's witness. Formally, there exists a simulator which, given access only to the statement \\(x\\), can generate a view for \\(V^*\\) that is indistinguishable from its view in the real execution. This property comes in computational and information-theoretic variants (depending on the type of indistinguishability of the two transcripts)."},{"location":"Areas-of-Cryptography/zk/#proofs-and-arguments","title":"Proofs and Arguments","text":"<p>By definition, proof systems are complete and sound. Based on the strength of the soundness, we make a distinction betweeen \"arguments\" and \"proofs\":</p> Argument Completeness holds perfectly. Soundness holds only against a computationally bounded cheating prover (i.e., computational soundness). For this reason, arguments are sometimes referred to as \"computationally sound proofs\". Proof Completeness holds perfectly. Soundness holds against a computationally unbounded cheating prover (i.e., statistical or even perfect soundness)."},{"location":"Areas-of-Cryptography/zk/#types-of-zero-knowledge-proofs","title":"Types of zero-knowledge proofs","text":"<p>Zero-knowledge proofs are named in a fairly self-explanatory way by combining their properties into an acronym. </p> Argument of Knowledge (AoK) Argument where the (computational) soundness is knowledge soundness. Properties: completeness, computational knowledge soundness. Proof of Knowledge (PoK) Proof where the soundness is knowledge soundness. Properties: completeness, knowledge soundness. Probabilistically Checkable Proof (PCP) Interactive Oracle Proof (IOP) Sometimes referred to as probabilistically checkable interactive proofs (PCIP), this is an interactive variant of PCPs. NIWI Non-Interactive Witness Indistinguishable proof. Properties: non-interactivity (\"NI\"), witness indistinguishability (\"WI\"), completeness and soundness (\"proof\"). NIZK Non-Interactive Zero Knowledge proof. Properties: non-interactivity (\"NI\"), zero-knowledge (\"ZK\"), completeness and soundness (\"proof\"). SNARG (SNArg) Succinct Non-interactive Argument. Properties: succinctness (\"S\"), non-interactivity (\"N\"), completeness and computational soundness (\"Arg\"). SNARK (SNArK) <p>Succinct Non-interactive Argument of Knowledge. Properties: succinctness (\"S\"), non-interactivity (\"N\"), completeness and knowledge soundness (\"ArK\").</p> zk-SNARK zero-knowledge SNARK. Properties: the above plus zero-knowledge (\"zk\"). STARK (STArK) Scalable (NOT \"succinct\") Transparent Argument of Knowledge. Properties: Fast verifier and prover time (\"S\"), transparent/no trusted setup (\"T\"), completeness and knowledge soundness (\"ArK\"). DV-NIZK Designated Verifier NIZK."},{"location":"Areas-of-Cryptography/zk/#polynomial-iops","title":"Polynomial IOPs","text":""},{"location":"Areas-of-Cryptography/zk/#sigma-protocols","title":"Sigma protocols","text":"<p>A sigma protocol (\u03a3-protocol) is a 3-round interactive HVZK PoK. Put another way, a sigma-protocol has the following properties:  </p> <ul> <li>perfect completeness</li> <li>special soundness (here, this implies knowledge soundness, so the protocol is a PoK)</li> <li>honest verifier zero-knowledge (HVZK)</li> </ul> <p>Any sigma protocol proving that \\((x, w)\\) is in some relation \\(R\\) follows the same outline:</p> <ol> <li>Prover \\(P\\) sends a first message \\(a\\) (the commitment)</li> <li>Verifier \\(V\\) responds with a uniformly random challenge \\(c\\)</li> <li>\\(P\\) uses the challenge to generate a response \\(z\\)</li> </ol> <p>Lastly, \\(V\\) must output either \"accept\" or \"reject\" as a deterministic function of \\(x\\) and the transcript \\((a, c, z)\\).</p> <p>Sigma protocols can be made non-interactive via the Fiat-Shamir transform. They can also be composed in the following ways, so that the languages they operate over are composed:</p> OR composition AND composition <p>Further Reading</p> <p>\"On \u03a3-protocols\" by Ivan Damg\u00e5rd \"Sigma Protocols\" slides by Benny Pinkas</p> <p></p> <p>Sigma protocol: DLog [Schnorr'89]</p> SchemeProperties <p>Public parameters: Group \\(\\mathbb{G}\\) of prime order \\(p\\). Prover: \\(y, b \\in \\mathbb{G}\\) and \\(x \\in \\mathbb{Z}_p\\). Verifier: \\(y, b \\in \\mathbb{G}\\) To prove knowledge of the discrete logarithm \\(x\\) such that \\(y = b^x\\), </p> <ol> <li>The prover P samples \\(r \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\) and sends \\(a := b^r\\) to the verifier V</li> <li>V sends back a uniform challenge \\(c \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\)</li> <li>P sends \\(z := r + c \\cdot x\\)</li> <li>V checks that \\(b^z = a \\cdot y^{c}\\)</li> </ol> <p>Correctness holds since \\(a \\cdot y^{c} = (b^r) \\cdot (b^x)^{c} = b^{r + x \\cdot c}\\).</p> <ul> <li>HVZK</li> <li>PoK</li> <li>[Cramer'97] generalizes this to knowledge of a homomorphism preimage</li> </ul> <p>Sigma protocol: DDH</p> SchemeProperties <p>Sigma protocol: DLEq [Chaum-Pedersen'92]</p> SchemeProperties <p>Public parameters: Group \\(\\mathbb{G}\\) of prime order \\(p\\). Prover: \\(y_1,b_1,y_2,b_2 \\in \\mathbb{G}\\) and \\(x \\in \\mathbb{Z}_p\\). Verifier: \\(y_1,b_1,y_2,b_2 \\in \\mathbb{G}\\) To prove equality of the discrete logarithms of \\(y_1,y_2\\) w.r.t. \\(b_1,b_2\\), i.e., \\(y_1 = b_1^x\\) and \\(y_2 = b_2^x\\): </p> <ol> <li>The prover P samples \\(r \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\) and sends \\(a_1 := b_1^r\\), \\(a_2 := b_2^r\\) to the verifier V</li> <li>V sends back a uniform challenge \\(c \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\)</li> <li>P sends \\(z := r + c \\cdot x\\)</li> <li>V checks that \\(b_1^z = a_1 \\cdot y_1^{c}\\) and \\(b_2^z = a_2 \\cdot y_2^{c}\\)</li> </ol> <p>Correctness holds since \\(a_i \\cdot y_i^{c} = (b_i^r) \\cdot (b_i^x)^{c} = b_i^{r + x \\cdot c}\\) for \\(i=1,2\\) where (crucially) the same \\(r,z\\) are used.</p> <p> </p> <p>Sigma protocol: Pedersen opening</p> SchemeProperties"},{"location":"Areas-of-Cryptography/zk/#mpc-in-the-head","title":"MPC-in-the-Head","text":""},{"location":"Cryptographic-Primitives/commitments/","title":"Commitment schemes","text":"<p>A commitment scheme consists of a commitment algorithm \\(\\sf Com\\) and an opening (decommitment) algorithm \\(\\sf Open\\). The opening can be checked via an algorithm \\(\\sf Vrfy\\).</p> <ul> <li>\\({\\sf Com}(m) \\to {\\sf com}\\): Commit to a message \\(m\\) with the commitment \\(\\sf com\\).</li> <li>\\({\\sf Open}({\\sf com}) \\to (m, \\pi)\\): Open the commitment to a message \\(m\\), with a proof \\(\\pi\\) to show correctness of the opening.</li> <li>\\({\\sf Vrfy}({\\sf com}, m, \\pi) \\to \\{0,1\\}\\): Check that the opening is correct.</li> </ul> <p>Pedersen commitments</p> SchemeProperties <p>Parameters: A group \\(\\mathbb{G}\\) of prime order \\(p\\) and generators \\(g,h \\in \\mathbb{G}\\).</p> <ul> <li>\\(\\underline{{\\sf Com}(m) \\to {\\sf com}}\\): output \\({\\sf com} = g^m h^r\\) where \\(r \\gets^\\$ \\mathbb{Z}_q\\).</li> <li>\\(\\underline{{\\sf Open}({\\sf com}) \\to (m, r)}\\): Output \\(m\\) and the randomness \\(r\\) that was used to compute \\(\\sf com\\). </li> <li>\\(\\underline{{\\sf Vrfy}({\\sf com}, m, r) \\to \\{0,1\\}}\\): The verifier checks that \\({\\sf com} = g^m h^r\\).</li> </ul> <ul> <li>computationally binding (by DLog assumption)</li> <li>unconditionally (information-theoretically) hiding</li> </ul>"},{"location":"Cryptographic-Primitives/commitments/#properties","title":"Properties","text":"Hiding Seeing \\(\\sf com\\) should reveal no information about \\(m\\). Binding It should be infeasible to open \\(\\sf com\\) to a different message \\(m' \\neq m\\) (i.e., find some other opening \\((m', \\pi') \\neq (m, \\pi)\\) so that \\({\\sf Vrfy}({\\sf com}, m', \\pi') = 1\\)). <p>Hiding vs. binding tradeoff</p> <p>There is an inherent tradeoff between the strength of the hiding and binding properties of a scheme: if a scheme is perfectly hiding, it can be only computationally binding; and vice versa.</p>"},{"location":"Cryptographic-Primitives/commitments/#types-of-commitments","title":"Types of commitments","text":"<p>Besides the basic commitment functionality, there are additional \"fancier\" types of commitment schemes.</p> Polynomial commitment <p>Allows one to commit to a polynomial \\(f(X)\\) and later open it at individual points, e.g., reveal \\(f(b)\\).</p> <p>KZG polynomial commitment [KZG10]</p> Scheme (multiplicative notation)Scheme (additive notation)PropertiesFurther reading <p>Parameters: Let \\(\\mathbb{G}\\) be an elliptic curve group of prime order \\(p\\) with generator \\(g\\) and \\(d\\) be the degree of the polynomial to commit to. Furthermore, let \\(e: \\mathbb{G} \\times \\mathbb{G} \\mapsto \\mathbb{G}_T\\) be a bilinear pairing.</p> <ul> <li>\\(\\underline{{\\sf Setup}({\\sf params}) \\to {\\sf crs}}\\): Using the parameters, compute \\({\\sf crs} = \\{{\\sf crs}_0, {\\sf crs}_1, {\\sf crs}_2, \\dots, {\\sf crs}_d\\} =\\) \\(\\{g, g^{\\tau}, g^{\\tau^2}, \\dots, g^{\\tau^d}\\}\\), where \\(\\tau \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\).</li> <li> <p>\\(\\underline{{\\sf Com}({\\sf crs}, f(X)) \\to {\\sf com}}\\): The commitment to the polynomial \\(f(X) = f_0 + f_1 X + \\dots + f_d X^d\\) is \\(g^{f(\\tau)}\\), which can be computed from the \\(\\sf crs\\) as </p> \\[C_f = {\\sf crs}_0^{f_0} \\cdot {\\sf crs}_1^{f_1} \\cdots {\\sf crs}_d^{f_d}\\] \\[= g^{f_0} \\cdot g^{f_1 \\tau} \\cdots g^{f_d \\tau^d} = g^{f(\\tau)}.\\] <p>Output \\({\\sf com} := C_f\\).</p> </li> <li> <p>\\(\\underline{{\\sf Open}({\\sf crs}, {\\sf com}, b) \\to (c, \\pi)}\\): to prove that the commitment \\(C_f\\) to \\(f\\) opens to \\(c\\) at \\(b\\), i.e. that \\(f(b) = c\\), compute \\(C_q \\gets {\\sf Com}({\\sf crs}, q(X))\\), where </p> \\[ q(X) = \\frac{f(X) - f(b)}{X - b} = \\frac{f(X) - c}{X - b} \\] <p>(this is a polynomial by Little B\u00e9zout's Theorem). Set \\(\\pi := C_q\\). </p> </li> <li> <p>\\(\\underline{{\\sf Vrfy}({\\sf crs}, {\\sf com}, (b, c), \\pi)}\\): Remember \\({\\sf com} = C_f\\) and \\(\\pi = C_q\\). The verifier checks that </p> \\[e(C_q, g^{\\tau} / g^b) = e(C_f / g^c, g)\\] <p>(where \\(g^{\\tau} = {\\sf crs}_1\\)).</p> </li> </ul> <p>Parameters: Let \\(\\mathbb{G}\\) be an elliptic curve group of prime order \\(p\\) with generator \\(G\\) and \\(d\\) be the degree of the polynomial to commit to. Furthermore, let \\(e: \\mathbb{G} \\times \\mathbb{G} \\mapsto \\mathbb{G}_T\\) be a bilinear pairing.</p> <ul> <li>\\(\\underline{{\\sf Setup}({\\sf params}) \\to {\\sf crs}}\\): Using the parameters, compute \\({\\sf crs} = \\{{\\sf crs}_0, {\\sf crs}_1, {\\sf crs}_2, \\dots, {\\sf crs}_d\\} =\\) \\(\\{g, g^{\\tau}, g^{\\tau^2}, \\dots, g^{\\tau^d}\\}\\), where \\(\\tau \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\).</li> <li> <p>\\(\\underline{{\\sf Com}({\\sf crs}, f(X)) \\to {\\sf com}}\\): The commitment to the polynomial \\(f(X) = f_0 + f_1 X + \\dots + f_d X^d\\) is \\(f(\\tau) \\cdot G\\), which can be computed from the \\(\\sf crs\\) as </p> \\[C_f = f_0 {\\sf crs}_0 + f_1 {\\sf crs}_1 + \\dots + f_d {\\sf crs}_d\\] \\[= f_0 G + f_1 \\tau G + \\dots f_d \\tau^d G = f(\\tau) \\cdot G.\\] <p>Output \\({\\sf com} := C_f\\).</p> </li> <li> <p>\\(\\underline{{\\sf Open}({\\sf crs}, {\\sf com}, b) \\to (c, \\pi)}\\): to prove that the commitment \\(C_f\\) to \\(f\\) opens to \\(c\\) at \\(b\\), i.e. that \\(f(b) = c\\), compute \\(C_q \\gets {\\sf Com}({\\sf crs}, q(X))\\), where </p> \\[ q(X) = \\frac{f(X) - f(b)}{X - b} = \\frac{f(X) - c}{X - b} \\] <p>(this is a polynomial by Little B\u00e9zout's Theorem). Set \\(\\pi := C_q\\). </p> </li> <li> <p>\\(\\underline{{\\sf Vrfy}({\\sf crs}, {\\sf com}, (b, c), \\pi)}\\): Remember \\({\\sf com} = C_f\\) and \\(\\pi = C_q\\). The verifier checks that </p> \\[e(C_q, \\tau G - bG) = e(C_f - cG, G)\\] <p>(where \\(\\tau G = {\\sf crs}_1\\)).</p> </li> </ul> <ul> <li>Computationally binding (\\(t\\)-SDH)</li> <li>Computationally hiding (DLog)</li> <li>The prover can do a full open and reveal all the evaluations by simply sending a candidate polynomial \\(f'(X)\\); the verifier checks that \\({\\sf Com}({\\sf crs}, f'(X)) = {\\sf com}\\). There is an optimization [FK20] to do this in \\(O(d\\log{d})\\) instead of \\(O(d^2)\\).</li> <li>There is also a batch mode in which the prover can open \\(t &lt; d\\) points, which the verifier can check with a single pairing. See \"Further reading\".</li> <li>Trusted setup: the scheme relies on a trusted setup, i.e. a well-formed CRS. (On the plus side, the CRS is of the \"powers-of-tau\" variant, which is fairly easy to generate via an MPC protocol (e.g., 2022/1592).)</li> </ul> <p>For a more detailed description of the scheme, see https://risencrypto.github.io/Kate/.</p> Vector commitment <p>A vector commitment allows one to commit to a vector \\(\\vec{v} = (v_1, \\dots, v_n)\\) and later individually open elements \\(v_i\\). (Note that a polynomial commitment to a polynomial of degree \\(d\\) can be thought of as a vector commitment to \\(d+1\\) points.)</p> <p>Merkle tree</p> <p>Libert-Yung VC [LY10]</p> Construction <p>This is a modified version of the original Libert-Yung VC, which was \"mercurial\", meaning it allowed both \"hard\" (normal) and \"soft\" (open to any message a commitment originally made to \"no message\") openings.</p> <p>Parameters: Let \\(\\mathbb{G},\\mathbb{G}_T\\) be bilinear groups of prime order \\(p\\) and \\(e: \\mathbb{G} \\times \\mathbb{G} \\rightarrow \\mathbb{G}_T\\) be a bilinear pairing. Let \\(g \\in \\mathbb{G}\\) be a random generator.</p> <ul> <li> <p>\\(\\underline{{\\sf Setup}(1^\\lambda, q) \\to {\\sf crs}}\\): To set up a VC for vectors of length at most \\(q\\), sample (a trapdoor) \\(z \\stackrel{\\$}{\\gets} \\mathbb{Z}_p^*\\) and compute \\(h_i := g^{z^i}\\) for \\(i \\in [2q] \\setminus \\{q+1\\}\\). Output \\({\\sf crs} := (h_1, \\dots, h_q, h_{q+2}, \\dots, h_{2q})\\).</p> </li> <li> <p>\\(\\underline{{\\sf Com}({\\sf crs}, \\vec{v}) \\to {\\sf com}}\\): To commit to \\(\\vec{v} = (m_1, \\ldots, m_q)\\), compute</p> \\[C := h_1^{m_1} h_2^{m_2} \\dots h_q^{m_q}\\] <p>and output \\(C\\) as the commitment.</p> </li> <li> <p>\\(\\underline{{\\sf Open}({\\sf crs}, {\\sf com}, i) \\to (m_i, \\Lambda_i)}\\): Compute \\(\\Lambda_i := \\prod_{j=1,j \\neq i}^{q} g_{q+1-j+i}^{m_j}\\).</p> </li> <li> <p>\\(\\underline{{\\sf Vrfy}({\\sf crs}, {\\sf com}, (i, m_i), \\Lambda_i) \\to \\{0,1\\}}\\): Given an opening \\((i, m_i)\\) for the commitment \\(\\sf com\\) and an opening proof \\(\\Lambda_i\\), a party can verify the correctness of the opening by checking that </p> \\[e({\\sf com}, h_{q+1-i}) = e(\\Lambda_i, g) \\cdot e(h_i^{m_i}, h_{q+1-i}).\\] </li> </ul> <p>(Updatable) VC from CDH [CF13]</p> ConstructionPropertiesFurther reading <p>Parameters: Let \\(\\mathbb{G},\\mathbb{G}_T\\) be bilinear groups of prime order \\(p\\) and \\(e: \\mathbb{G} \\times \\mathbb{G} \\rightarrow \\mathbb{G}_T\\) be a bilinear pairing. Let \\(g \\in \\mathbb{G}\\) be a random generator.</p> <ul> <li> <p>\\(\\underline{{\\sf Setup}(1^\\lambda, q) \\to {\\sf pp}}\\): To set up a VC for vectors of length at most \\(q\\), sample (trapdoors) \\(z_1, \\ldots, z_q \\stackrel{\\$}{\\gets} \\mathbb{Z}_p\\). Compute \\(h_i := g^{z_i}\\) and \\(h_{i,j} = g^{z_i z_j}\\) for \\(i,j = 1, \\ldots, q\\) with \\(j \\neq i\\). Output \\({\\sf pp} := (g, \\{h_i\\}_{i \\in [q]}, \\{h_{i,j}\\}_{i,j \\in [q], i \\neq j})\\).</p> </li> <li> <p>\\(\\underline{{\\sf Com}({\\sf pp}, \\vec{v}) \\to {\\sf com}}\\): To commit to \\(\\vec{v} = (m_1, \\ldots, m_q)\\), compute</p> \\[C := h_1^{m_1} h_2^{m_2} \\dots h_q^{m_q}\\] <p>(same as Libert-Yung VC) and output \\(C\\) as the commitment.</p> </li> <li> <p>\\(\\underline{{\\sf Open}({\\sf pp}, {\\sf com}, i) \\to (m_i, \\Lambda_i)}\\): Compute \\(\\Lambda_i := \\prod_{j=1,j\\neq i}^{q} h_{i,j}^{m_j} = \\prod_{j=1,j\\neq i}^{q} \\left( h_j^{m_j} \\right)^{z_i}\\).</p> </li> <li> <p>\\(\\underline{{\\sf Vrfy}({\\sf pp}, {\\sf com}, (i, m_i), \\Lambda_i) \\to \\{0,1\\}}\\): Given an opening \\((i, m_i)\\) for the commitment \\(\\sf com\\) and an opening proof \\(\\Lambda_i\\), a party can verify the correctness of the opening by checking that </p> \\[e({\\sf com}/h_i^{m_i}, h_i) = e(\\Lambda_i, g).\\] </li> </ul> <ul> <li> <p>\\(\\underline{{\\sf Update}({\\sf pp}, {\\sf com}, i, m, m') \\to {\\sf com}'}\\): To update the \\(i\\)th entry \\(m\\) to \\(m'\\), compute an updated commitment \\({\\sf com}' := {\\sf com} \\cdot h_i^{m'-m}\\).</p> </li> <li> <p>\\(\\underline{{\\sf PfUpdate}({\\sf pp}, {\\sf com}, (i, m, m'), \\Lambda_j) \\to \\Lambda_j'}\\): A proof for the opening of position \\(j\\) which was valid w.r.t. \\(\\sf com\\) can be updated for \\(\\sf com'\\) as follows:</p> <ul> <li>If \\(j \\neq i\\), set \\(\\Lambda_j' := \\Lambda_j \\cdot (h_i^{m'-m})^{z_j} = \\Lambda_j \\cdot h_{j,i}^{m'-m}\\).</li> <li>If \\(j = i\\), the proof \\(\\Lambda_i\\) remains unchanged.</li> </ul> </li> </ul> <ul> <li>Security holds by the CDH assumption in bilinear groups</li> <li>The scheme is updatable, so the commitment can be updated to reflect an update to one entry of the vector</li> </ul> <ul> <li>See the paper for details as well as an additional updatable VC from the RSA assumption.</li> </ul> Cryptographic accumulator <p>An accumulator (succinctly) commits to a set of elements. It should also be possible to provide short proofs of (non-)membership of elements in the set. An accumulator is the unordered sibling of a vector commitment.</p> <p>RSA accumulator</p> Functional commitment"},{"location":"Cryptographic-Primitives/encryption/","title":"Encryption","text":"<p>Summary</p> <p>Encryption schemes are used to ensure confidentiality.</p> <p>An encryption scheme consists of three algorithms: a key generation algorithm \\(\\mathsf{Gen}\\) (or \\(\\mathsf{KGen}\\)) that takes as input a security parameter and outputs a key (or key pair), an encryption algorithm \\(\\mathsf{Enc}\\) that takes a (public) key and a message and outputs a ciphertext, and a decryption algorithm \\(\\mathsf{Dec}\\) that takes a (private) key and a ciphertext and outputs a message. Some schemes with advanced properties may add additional algorithms.</p> <p>Encryption scheme syntax</p> <p>An encryption scheme \\(\\Pi_\\mathsf{E}\\) is a triple of algorithms \\((\\mathsf{Gen}, \\mathsf{Enc}, \\mathsf{Dec})\\):</p> <ul> <li>\\(({\\sf pk}, {\\sf sk}) \\gets \\mathsf{Gen}(1^\\lambda)\\)</li> <li>\\(c \\gets \\mathsf{Enc}({\\sf pk}, m)\\)</li> <li>\\(m \\gets \\mathsf{Dec}({\\sf sk}, c)\\)</li> </ul> <p>In the case of a symmetric (private-key) encryption scheme, the private and public key are the same.</p> Correctness For all key (pairs) output by \\(\\sf Gen\\) we have \\({\\sf Dec}({\\sf sk}, {\\sf Enc}({\\sf pk}, m)) = m\\). The correctness notions for the fancier encryption schemes below are extensions of this basic notion: basically, if everything is run honestly, a ciphertext should decrypt to its original message."},{"location":"Cryptographic-Primitives/encryption/#basic-types-of-encryption","title":"Basic Types of Encryption","text":"Asymmetric (public-key) encryption <p>One key (the recipient's public key) is used for encryption, while another key (the corresponding secret key) is used for decryption. The private and public keys form a key pair.  </p> <p></p> <p>ElGamal encryption</p> SchemeProperties <p>\\(\\underline{\\mathsf{Gen}}\\): Choose a uniform cyclic prime-order group \\(\\mathbb{G}\\), where \\(q\\) is the order and \\(g\\) is the generator (these are announced publicly). Output the secret key \\(x \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q\\) and the public key \\(g^x \\in \\mathbb{G}\\).</p> <p>\\(\\underline{\\mathsf{Enc}(pk, m)}\\):</p> <ul> <li>return \\(c := (g^r, m \\cdot pk^r)\\) where \\(r \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_p\\)</li> </ul> <p>\\(\\underline{\\mathsf{Dec}(sk, c := (c_1, c_2))}:\\)</p> <ul> <li>return \\(m \\gets c_2/c_1^{sk}\\). Note this equals \\(m \\cdot pk^r/(g^r)^{sk} = m \\cdot g^{xr}/g^{rx} = m\\)</li> </ul> <ul> <li>CPA-secure (by DDH assumption)</li> <li>unconditionally malleable</li> </ul> <p></p> <p>RSA encryption</p> SchemeProperties <p>\\(\\underline{\\mathsf{Gen}}\\): return the public key \\((n,e)\\) and private key \\(d\\), where</p> <ul> <li>\\(n:=pq\\) for two random distinct prime numbers \\(p,q\\) (this is sometimes called a semiprime)</li> <li>\\(1&lt;e&lt;\\varphi(n)\\) and \\(\\gcd(e,\\varphi(n))=1\\)<sup>2</sup></li> <li>\\(d \\equiv e^{-1}\\pmod{\\varphi(n)}\\)<sup>3</sup></li> </ul> <p>\\(\\underline{\\mathsf{Enc}(pk:=(n,e), m)}\\) where \\(0 \\le m &lt; n\\)<sup>1</sup>:  </p> <ul> <li>return \\(c \\equiv m^e \\pmod{n}\\)</li> </ul> <p>\\(\\underline{\\mathsf{Dec}(sk := d, c)}:\\) </p> <ul> <li>compute \\(c^d \\equiv (m^e)^d \\equiv m \\pmod{n}\\)</li> </ul> <p>Assuming a strong padding scheme, RSA is</p> <ul> <li>CCA-secure (by either the RSA assumption or the hardness of integer factorization; if either assumption is proven false the security of RSA is compromised)</li> </ul> <p></p> <p>Paillier encryption</p> <p></p> <p>Cramer-Shoup cryptosystem</p> SchemePropertiesFurther reading <ul> <li>CCA2-secure (by the DDH assumption)</li> </ul> <ul> <li>Cramer-Shoup cryptosystem on Wikipedia</li> </ul> Symmetric (secret-key) encryption <p>The same key is used for both decryption and encryption. This means the sender and recipient must somehow securely agree on a secret key; this is usually achieved either via key agreement protocols or by encrypting the symmetric key using public-key encryption.  </p> <p>Advanced Encryption Standard (AES)</p> <p>One-time Pad</p>"},{"location":"Cryptographic-Primitives/encryption/#advanced-types-of-encryption","title":"Advanced Types of Encryption","text":"Attribute-based encryption (ABE) <p>Policy-based access to encrypted data (general case of identity-based encryption). The policy is not necessarily hidden. A trusted third party is required to distribute policy keys only to parties that meet the policy.</p> <p>ABE syntax</p> <ul> <li>\\(({\\sf mpk}, {\\sf msk}) \\gets \\mathsf{Setup}(1^\\lambda)\\): set up master keypair</li> <li>\\({\\sf sk}_{f} \\gets \\mathsf{KGen}({\\sf msk}, f)\\): generate a secret key for some access control policy \\(f: \\{0, 1\\}^* \\rightarrow \\{0,1\\}\\)</li> <li>\\(c_a \\gets \\mathsf{Enc}({\\sf mpk}, a, m)\\): encrypt to all users with the attribute \\(a\\)</li> <li>\\(\\{m, \\perp\\} \\gets \\mathsf{Dec}(sk_f, c_a)\\): decrypt with secret key for policy \\(f\\) to get the plaintext; returns \\(\\perp\\) if \\(c\\) was encrypted to an attribute \\(a\\) which doesn't meet the policy, that is, \\(f(a) \\neq 1\\)</li> </ul> Broadcast encryption Functional encryption (FE) <p>An encryption scheme in which it is possible to issue \"function keys\", e.g. a key \\(k_f\\) that decrypts the ciphertext into a function \\(f(m)\\) of the plaintext \\(m\\).</p> <p>FE syntax</p> <ul> <li>\\(({\\sf mpk}, {\\sf msk}) \\gets \\mathsf{Setup}(1^\\lambda)\\): set up master keypair</li> <li>\\({\\sf sk}_f \\gets \\mathsf{KGen}({\\sf msk}, f)\\): generate a function secret key</li> <li>\\(c \\gets \\mathsf{Enc}({\\sf mpk}, m)\\): encrypt under master public key</li> <li>\\(f(m) \\gets \\mathsf{Dec}({\\sf sk}_f, c)\\): decrypt with function secret key to obtain the function of the plaintext</li> </ul> Fully homomorphic encryption (FHE) <p>Further reading</p> <p>FHE.org Resources</p> Identity-based encryption (IBE) <p>Identity-based access to encrypted data. A trusted third party is required to issue keys to identities. The reasoning behind the introduction of IBE was to avoid the complicated public-key infrastructure (PKI), in particular the issue of public key distribution, by allowing encrypters to encrypt directly to an identifier (e.g. a party's name, email, or phone number) without having to obtain the party's public key.</p> <p>IBE syntax</p> <ul> <li>\\(({\\sf mpk}, {\\sf msk}) \\gets \\mathsf{Setup}(1^\\lambda)\\): set up master keypair</li> <li>\\({\\sf sk}_{\\sf id} \\gets \\mathsf{KGen}({\\sf msk}, {\\sf id})\\): generate an identity's secret key</li> <li>\\(c_{\\sf id} \\gets \\mathsf{Enc}({\\sf mpk}, {\\sf id}, m)\\): encrypt directly to an identity</li> <li>\\(\\{m, \\perp\\} \\gets \\mathsf{Dec}(sk_y, c_{\\sf id})\\): decrypt with identity secret key to get the plaintext; returns \\(\\perp\\) if \\(c\\) was encrypted to an identity \\({\\sf id} \\neq y\\)</li> </ul> <p>Note that IBE can be viewed as a specific case of ABE where \\(f(a) = \\begin{cases}1 &amp; a = {\\sf id}\\\\ 0 &amp; \\text{otherwise}\\end{cases}\\).</p> <p>Boneh-Franklin IBE</p> Hierarchical IBE (HIBE) Registration-based encryption (RBE) <p>Similar to IBE, but without a trusted third party; instead there is a transparent party called the \"key curator\" who is only responsible for accumulating keys of parties who register in the system, but does not hold any secrets.</p> <p>RBE syntax</p> <p>Further Reading</p> <ul> <li>Introduced in Registration-based encryption: removing private-key generator from IBE [GHMR18]</li> <li>Registration-based encryption from standard assumptions [GHMRS19]</li> <li>Verifiable registration-based encryption [GV20]</li> <li>Efficient registration-based encryption [GKMR23]</li> </ul> Rerandomizable encryption <p>An encryption scheme in which the ciphertext can be updated into a new and unrelated ciphertext while keeping the underlying plaintext the same.</p> <p>Rerandomizable encryption syntax</p> <ul> <li>\\(\\sf Gen, Enc, Dec\\) as usual</li> <li>\\(c' \\gets \\mathsf{Rerand}(c, r)\\): rerandomize the ciphertext using randomness \\(r\\) without changing the underlying message (\\(\\mathsf{Dec}({\\sf sk}, c) = \\mathsf{Dec}({\\sf sk}, c')\\))</li> </ul> Structured encryption Witness encryption (WE) Extractable witness encryption (EWE)"},{"location":"Cryptographic-Primitives/encryption/#security-notions","title":"Security Notions","text":"Circular security Usually, our security definitions say nothing about what happens when we encrypt the secret key itself with the encryption scheme. If a scheme is circular secure, it is secure even when the message is (a function of) the secret key. This is also called key-dependent message security."},{"location":"Cryptographic-Primitives/encryption/#cpa-security","title":"CPA security","text":"<p>CPA stands for \"chosen plaintext attacks\", and security against these attacks can be formulated in two (equivalent) ways. </p> <p>The indistinguishability-based notion of CPA security is called IND-CPA security, and requires that an adversary cannot distinguish between encryption of two different messages:</p> <p>IND-CPA game</p> DescriptionDiagram <ol> <li>Challenger: \\(k \\gets Gen(1^n)\\)</li> <li>\\(\\mathcal{A}(1^n)\\) interacts with \\(Enc_k(\\cdot)\\) (in polynomial time)</li> <li>\\(\\mathcal{A}\\) outputs \\(m_0, m_1\\) of same length</li> <li>Challenger: \\(b \\gets \\{0,1\\}, c \\gets Enc_k(m_b)\\), send \\(c\\) to \\(\\mathcal{A}\\)</li> <li>\\(\\mathcal{A}\\) continues to interact with \\(Enc_k(\\cdot)\\) (in polynomial time)</li> <li>\\(\\mathcal{A}\\) outputs \\(b'\\)</li> </ol> <p>\\(\\mathcal{A}\\) wins if \\(b=b'\\), and the game outputs 1.  </p> <pre><code>sequenceDiagram\n    Note over Challenger: (1) Sample k #larr; Gen(1^n)\n    Note over Adversary: (2) Query Enc oracle (in poly time)\n    loop Enc oracle\n        Adversary--&gt;&gt;Challenger: m\n        Challenger--&gt;&gt;Adversary: Enc(k, m)\n    end\n    Adversary-&gt;&gt;Challenger: (3) m_0, m_1\n    Note over Challenger: (4) Sample b #larr; {0,1} &lt;br/&gt; c #larr; Enc(k, m_b)\n    Challenger-&gt;&gt;Adversary: c\n    Note over Adversary: (5) Query Enc oracle (in poly time)\n    loop Enc oracle\n        Adversary--&gt;&gt;Challenger: m\n        Challenger--&gt;&gt;Adversary: Enc(k, m)\n    end\n    %%loop Enc oracle\n    %%    Adversary-&gt;&gt;Adversary: query oracle (in poly time)\n    %%end\n    Adversary-&gt;&gt;Challenger: (6) b'\n    Note right of Challenger: Adversary wins if b=b'</code></pre> <p>The alternative formulation is the simulation-based semantic security (or SIM-CPA), which says that anything the adversary can compute from the ciphertext can also be computed (simulated) without the ciphertext. That is, the ciphertext does not reveal any new information to the adversary.</p> <p>These two notions have been shown to be equivalent: semantic security \u21d2 IND-CPA and IND-CPA \u21d2 semantic security, therefore semantic security \u21d4 IND-CPA.</p> <p>There are several techniques for transforming a CPA-secure encryption scheme to CCA-secure one, including the FO transform and the Naor-Yung paradigm.</p> OW-CPA one-way CPA security."},{"location":"Cryptographic-Primitives/encryption/#cca-security","title":"CCA security","text":"<p>CCA stands for \"chosen ciphertext attacks\", and security against these attacks if normally formulated as an indistinguishability-based notion (IND-CCA). There are two variants of IND-CCA security: IND-CCA1 and IND-CCA2. Both are stronger than IND-CPA security because the adversary is additionally given access to a decryption oracle. IND-CCA (without a number) usually refers to IND-CCA2.</p> IND-CCA1 <p>Security against non-adaptive (\"lunchtime\") chosen ciphertext attack. Weaker than IND-CCA2.</p> <p>Examples: Naor-Yung encryption</p> <p>IND-CCA1 game</p> DescriptionDiagram <ol> <li>Challenger: \\(k \\gets Gen(1^n)\\)</li> <li>\\(\\mathcal{A}(1^n)\\) interacts with \\(Enc_k(\\cdot)\\) and \\(Dec_k(\\cdot)\\) (in polynomial time)</li> <li>\\(\\mathcal{A}\\) outputs \\(m_0, m_1\\) of same length</li> <li>Challenger: \\(b \\gets \\{0,1\\}, c \\gets Enc_k(m_b)\\), send \\(c\\) to \\(\\mathcal{A}\\)</li> <li>\\(\\mathcal{A}\\) can perform some operations (in polynomial time) </li> <li>\\(\\mathcal{A}\\) outputs \\(b'\\)</li> </ol> <p>\\(\\mathcal{A}\\) wins if \\(b=b'\\), and the game outputs 1.</p> <pre><code>sequenceDiagram\n    Note over Challenger: (1) Sample k #larr; Gen(1^n)\n    Note over Adversary: (2) Query Enc and Dec oracles &lt;br/&gt; (in poly time)\n    par Enc oracle\n        loop \n            Adversary--&gt;&gt;Challenger: m\n            Challenger--&gt;&gt;Adversary: Enc(k, m)\n        end\n    and Dec oracle\n        loop \n            Adversary--&gt;&gt;Challenger: c\n            Challenger--&gt;&gt;Adversary: Dec(k, c)\n        end\n    end\n    Adversary-&gt;&gt;Challenger: (3) m_0, m_1\n    Note over Challenger: (4) Sample b #larr; {0,1} &lt;br/&gt; c #larr; Enc(k, m_b)\n    Challenger-&gt;&gt;Adversary: c\n    Note over Adversary: (5) Perform any operations (in poly time)\n    Adversary-&gt;&gt;Challenger: (6) b'\n    Note right of Challenger: Adversary wins if b=b'</code></pre> IND-CCA2 <p>Security against adaptive chosen ciphertext attack. In addition to its capabilities in the IND-CCA1 game, \\(\\mathcal{A}\\) now has access to the oracles after seeing \\(c\\).</p> <p>Examples: Dolev-Dwork-Naor, Cramer-Shoup</p> <p>IND-CCA2 game</p> DescriptionDiagram <ol> <li>Challenger: \\(k \\gets Gen(1^n)\\)</li> <li>\\(\\mathcal{A}(1^n)\\) interacts with \\(Enc_k(\\cdot)\\) and \\(Dec_k(\\cdot)\\) (in polynomial time)</li> <li>\\(\\mathcal{A}\\) outputs \\(m_0, m_1\\) of same length</li> <li>Challenger: \\(b \\gets \\{0,1\\}, c \\gets Enc_k(m_b)\\), send \\(c\\) to \\(\\mathcal{A}\\)</li> <li>\\(\\mathcal{A}\\) continues to interact with \\(Enc_k(\\cdot)\\) and \\(Dec_k(\\cdot)\\) (in polynomial time) but can't query \\(Dec_k(\\cdot)\\) on \\(c\\)</li> <li>\\(\\mathcal{A}\\) outputs \\(b'\\)</li> </ol> <p>\\(\\mathcal{A}\\) wins if \\(b=b'\\), and the game outputs 1.</p> <pre><code>sequenceDiagram\n    Note over Challenger: (1) Sample k #larr; Gen(1^n)\n    Note over Adversary: (2) Query Enc and Dec oracles &lt;br/&gt; (in poly time)\n    par Enc oracle\n        loop \n            Adversary--&gt;&gt;Challenger: m\n            Challenger--&gt;&gt;Adversary: Enc(k, m)\n        end\n    and Dec oracle\n        loop \n            Adversary--&gt;&gt;Challenger: c\n            Challenger--&gt;&gt;Adversary: Dec(k, c)\n        end\n    end\n    Adversary-&gt;&gt;Challenger: (3) m_0, m_1\n    Note over Challenger: (4) Sample b #larr; {0,1} &lt;br/&gt; c #larr; Enc(k, m_b)\n    Challenger-&gt;&gt;Adversary: c\n    Note over Adversary: (5) Continue querying Enc and Dec oracles &lt;br/&gt; (in poly time)\n    par Enc oracle\n        loop \n            Adversary--&gt;&gt;Challenger: m\n            Challenger--&gt;&gt;Adversary: Enc(k, m)\n        end\n    and Dec oracle\n        loop \n            Adversary--&gt;&gt;Challenger: c' #ne; c\n            Challenger--&gt;&gt;Adversary: Dec(k, c')\n        end\n    end\n    Adversary-&gt;&gt;Challenger: (6) b'\n    Note right of Challenger: Adversary wins if b=b'</code></pre> OW-CCA one-way CCA security.  replayable CCA (RCCA) <ol> <li> <p>A message \\(M\\) is turned into an integer \\(n\\) satisfying this property using an agreed-upon reversible padding scheme.\u00a0\u21a9</p> </li> <li> <p>\\(\\varphi\\) is Euler's totient function; as an optimization, many implementations use Carmicheal's totient function \\(\\lambda\\) instead. See the bottom of the key generation paragraph on Wikipedia for more information.\u00a0\u21a9</p> </li> <li> <p>e.g., using the extended Euclidean algorithm\u00a0\u21a9</p> </li> </ol>"},{"location":"Cryptographic-Primitives/hash/","title":"Hash Functions","text":"Hash function A function which maps arbitrary-sized data (messages) to fixed-size strings (hash values). That is, \\(f: \\{0,1\\}^* \\rightarrow \\{0,1\\}^n\\) for some arbitrary but fixed \\(n\\). Cryptographic hash function <p>A hash function which satisfies three properties: preimage resistance, second preimage resistance, and collision resistance:  </p> <ul> <li> preimage resistance </li> <li> second preimage resistance </li> <li> collision resistance </li> </ul> Correlation-intractability (CI) Merkle-D\u00e5mgard construction Universal hash function"},{"location":"Cryptographic-Primitives/key-exchange/","title":"Key Exchange","text":"Key Agreement <p>Diffie-Hellman Key Exchange</p> Non-interactive key exchange (NIKE) Password-authenticated key exchange (PAKE) Key-Derivation Function (KDF) Key Encapsulation Mechanism (KEM)"},{"location":"Cryptographic-Primitives/other/","title":"Other","text":"Message authentication code (MAC) One-way function (OWF) In a way this is also an assumption, since we don't know of any function that is provably hard to invert. Pseudo-random function (PRF) <p>A function that maps inputs to outputs so that the outputs appear randomly distributed. The function is deterministic in the sense that querying it on the same input always returns the same (random-looking) output.</p> <p>PRF security game</p> <p>Construction: PRF from PRG [GGM]</p> <p>Given a length-doubling PRG \\(G: \\{0, 1\\}^\\lambda \\rightarrow \\{0,1\\}^{2\\lambda}\\), we can construct a PRF \\(F: \\{0, 1\\}^\\lambda \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^\\lambda\\) which takes a \\(\\lambda\\)-bit key \\(k\\) and \\(n\\)-bit input \\(x\\) and outputs a pseudorandom \\(\\lambda\\)-bit value. The construction is described in this note. The idea is to construct a height-\\(n\\) tree of calls to \\(G\\) using \\(k\\) as the root. The output of \\(F(k,x)\\) is determined by following the path given by the bits of \\(x\\).</p> <p>Moreover, this construction is in fact a puncturable PRF: we can puncture out points by removing the PRG seeds in the tree along the path to that point.</p> Pseudo-random generator (PRG) <p>PRG security game</p> Pseudo-random permutation (PRP) Time-Lock Puzzle (TLP) Trapdoor function (TDF) <p>Construction: TDF from SIS</p>"},{"location":"Cryptographic-Primitives/signatures/","title":"Signatures","text":"<p>Summary</p> <p>Signatures are used to ensure authenticity.</p> <p>A digital signature scheme consists of three algorithms: a key generation algorithm \\(\\mathsf{Gen}\\) (or \\(\\mathsf{KGen}\\)) that takes no input and outputs a key pair, a signing algorithm \\(\\mathsf{Sign}\\) that takes a private key and a message and outputs a signature, and a verification algorithm \\(\\mathsf{Vrfy}\\) that takes a public key, a message, and a signature and outputs 1 (the signature is a valid signature on that message) or 0 (the signature is not valid on that message).</p> <p>Signature scheme syntax</p> <ul> <li>\\(({\\sf pk}, {\\sf sk}) \\gets \\mathsf{Gen}(1^\\lambda)\\)</li> <li>\\(\\sigma \\gets \\mathsf{Sign}({\\sf sk}, m)\\)</li> <li>\\(\\{0, 1\\} \\gets \\mathsf{Vrfy}({\\sf pk}, m, \\sigma)\\)</li> </ul> <p>For correctness, we require that for all key (pairs) output by \\(\\sf Gen\\) we have \\(\\mathsf{Vrfy}({\\sf pk}, m, \\mathsf{Sign}({\\sf pk}, m)) = 1\\).</p> <p>It is known that OWFs imply (one-time) signatures (OTS).</p> <p>One-time signatures (OTS) from OWFs [Lamport]</p> <p>OTS in turn imply many-time (i.e., regular) signatures:</p> <p>Many-time signatures from OTS</p> <p>The construction is a bit involved so it is given in a separate document. The general idea is to make a depth-\\(\\lvert m \\rvert\\) binary tree of OTS keypairs. Then each parent is used to sign the pair of verification keys below it, and the signature on \\(m\\) consists of the \\(\\lvert m \\rvert\\) signatures on the path the bits of \\(m\\) from the root to a leaf.</p>"},{"location":"Cryptographic-Primitives/signatures/#schemes","title":"Schemes","text":"<p>A common paradigm for a signature scheme is to instantiate a signature as a NIZK PoK of the secret key (additionally incorporating the message). See the \"Notes\" section of the Schnorr signature scheme below for a discussion of how that scheme fits into this paradigm; another example is Picnic, a NIST post-quantum cryptography candidate, which is essentially a proof of knowledge of the preimage of a one-way function.</p> <p></p> <p>Digital Signature Algorithm (DSA)</p> ConstructionAssumptions <p>DSA is an additive version of the Schnorr signature scheme (which can in turn be seen as a multiplicative version of DSA).</p> <p>Let \\(p,q\\) be primes such that \\(q\\) divides \\(p-1\\) and \\(G\\) be a group of order \\(p\\) with generator \\(g\\). Let \\(H\\) be a hash function.</p> <p>\\(\\underline{\\mathsf{Gen}}\\): return the secret key \\(sk \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q\\) and the public key \\(pk := g^{sk} \\mod{p}\\).</p> <p>\\(\\underline{\\mathsf{Sign}(sk, m)}\\): </p> <ul> <li>choose a one-time key \\(k \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q\\)</li> <li>compute a nonce \\(r := (g^k \\mod{p}) \\mod{q}\\) (if \\(r=0\\), start over with a different \\(k\\))</li> <li>compute \\(s := k^{-1} \\cdot (H(m) + r \\cdot sk) \\mod{q}\\) (if \\(s=0\\), start over with a different \\(k\\))</li> <li>output the signature \\(\\sigma := (s, r)\\).</li> </ul> <p>\\(\\underline{\\mathsf{Vrfy}(pk,m, \\sigma := (s,R))}\\): </p> <p>Check that the following hold:</p> <ul> <li>\\(r,s \\in \\mathbb{Z}_q\\)</li> <li>\\(r = (g^{u_1} {pk}^{u_2} \\mod{p}) \\mod{q}\\), where \\(u_1 := H(m) \\cdot s^{-1} \\mod{q}\\) and \\(u_2 := r \\cdot s^{-1} \\mod{q}\\)</li> </ul> <ul> <li>DLog</li> </ul> <p></p> <p>ECDSA signatures</p> Construction (additive notation)Assumptions <p>ECDSA is the elliptic-curve version of DSA.</p> <p>Let \\(G\\) be the base point of the elliptic curve, such that \\(G\\) has prime order \\(p\\). Use \\(\\times\\) to denote scalar multiplication of an elliptic curve point. We use lowercase variable names for scalars and uppercase variables for elliptic curve points.</p> <p>\\(\\underline{\\mathsf{Gen}}\\): \\(sk \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_p\\) and the public key \\(Q := {sk} \\times G\\).</p> <p>\\(\\underline{\\mathsf{Sign}(sk, m)}\\):</p> <ul> <li>choose a one-time key \\(k \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_p\\)</li> <li>compute \\(R := k \\times G\\) (if \\(R=0\\)<sup>1</sup>, start over with a different \\(k\\))</li> <li>compute \\(S := k^{-1} \\cdot (H(m) + sk \\times R)\\) (if \\(S=0\\), start over with a different \\(k\\))</li> <li>output the signature \\(\\sigma := (S, R)\\).</li> </ul> <p>\\(\\underline{\\mathsf{Vrfy}(Q,m, \\sigma := (S,R))}\\):  </p> <p>Check that the following hold:</p> <ul> <li>\\(Q,S,R\\) are valid elliptic-curve points (and not equal to the identity)</li> <li>compute \\(U_1 := H(m) S^{-1}\\) and \\(U_2 := R S^{-1}\\)</li> <li>\\(R = U_1 G + U_2 Q\\)</li> </ul> <ul> <li>DLog over elliptic curves</li> </ul> <p></p> <p>Schnorr signatures</p> Construction (additive notation)AssumptionsNotes <p>Let \\(G\\) be an elliptic curve group with generator \\(g\\) and order \\(q\\) and \\(H\\) be a hash function.</p> <p>\\(\\underline{\\mathsf{Gen}}\\): return the secret key \\(sk \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q\\) and the public key \\(pk := g \\cdot sk\\).  </p> <p>\\(\\underline{\\mathsf{Sign}(sk, m)}\\): </p> <ul> <li>choose a one-time key \\(k \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_q\\)</li> <li>compute a nonce \\(r := g \\cdot k\\)</li> <li>compute \\(s := k + H(r || m ) \\cdot sk \\mod q\\)</li> </ul> <p>Return the signature \\(\\sigma := (s, r)\\).</p> <p>\\(\\underline{\\mathsf{Vrfy}(pk,m, \\sigma := (s,r))}\\): return the truth value of \\(s \\cdot g =^? r + H(r || m) \\cdot pk\\).</p> <ul> <li>DLog</li> </ul> <p>Schnorr signatures can be viewed as a NIZK PoK of the discrete logarithm of the public key (i.e., knowledge of the secret key). Note that the Schnorr signing algorithm is essentially a standard sigma-protocol for DLog, made non-interactive with the Fiat-Shamir transform.</p> <p></p> <p>EdDSA</p> <p>EdDSA is a variant of the Schnorr signature scheme for twisted Edwards elliptic curves.</p> <p></p> <p>BLS signatures</p> Construction (additive notation)AssumptionsNotes <p>Let \\(\\mathbb{G}_1, \\mathbb{G}_2\\) be elliptic curve groups of order \\(p\\) generated by \\(P, Q\\), respectively, and \\(e\\) be an efficiently computable bilinear map on them. Let \\(H\\) be a hash function onto \\(\\mathbb{G}_1\\).</p> <p>\\(\\underline{\\mathsf{Gen}}\\): sample the secret key \\(x \\gets\\!\\!\\tiny{\\$}\\normalsize\\ \\mathbb{Z}_p\\) and compute the corresponding public key \\(V := xQ\\).</p> <p>\\(\\underline{\\mathsf{Sign}(sk, m)}\\): Output \\(\\sigma := x H(m)\\)</p> <p>\\(\\underline{\\mathsf{Vrfy}(pk,m, \\sigma := (s,r))}\\): check \\(e(\\sigma, Q) = e(H(m), V)\\).</p> <ul> <li>co-Gap Diffie Hellman</li> </ul> <p>The scheme extends straightforwardly to (a robust, t-out-of-n) threshold signature. Parties receive Shamir secret shares \\(x_i\\) of the secret key, and the public key and partial public keys \\(V_i := x_i Q\\) are published for all \\(i\\).</p> <p>To sign a message, parties that want to participate produce a partial signature (a share of the full signature) \\(\\sigma_i\\) by signing using their share of the secret key. That is, \\(\\sigma_i = x_i H(m)\\). The full signature is then </p> \\[ \\prod_i \\lambda_i \\sigma_i \\] <p>where the \\(\\lambda_i\\) is each party's Lagrange interpolation at 0. That is,</p> \\[ \\sigma = \\prod_i \\lambda_i (x_i H(m)) = (\\sum_i \\lambda_i x_i) H(m) = x H(m) \\] <p>where Shamir reconstruction is happening homomorphically in the \"exponent\".</p> <p>This scheme is also robust: the validity of the signature share \\(\\sigma_i\\) can be checked by checking that \\((Q, V_i, H(m), \\sigma_i)\\) is a co-Diffie-Hellman tuple (of the form \\((Q, a Q, H, b H)\\) where \\(a=b\\)).</p> <p></p> <p>CL signatures</p>"},{"location":"Cryptographic-Primitives/signatures/#other-types","title":"Other types","text":"Aggregate signatures A signature scheme with the property that an arbitrary number of signatures \\(\\sigma_1, \\dots, \\sigma_\\ell\\) on potentially different messages \\(m_1, \\dots, m_\\ell\\) produced by potentially different signers \\(P_1, \\dots, P_\\ell\\) can be aggregated into a single signature \\(\\sigma\\) which can be used to verify the authenticity of all \\(\\ell\\) individiual signatures. Compared to multi-signatures and threshold signatures, the final signature spans multiple different messages. Blind signatures <p>Blind Schnorr signatures</p> Designated-verifier (DV) signatures Instead of being publicly verifiable, a signature can only be verified by a specific party (the DV). Message authentication codes (MACs) can be thought of as DV-sigs, since a secret key is necessary to verify a MAC, so only parties that know the secret key can perform verification. Group signatures One person in a group can produce a signature on behalf of everyone in the group. The signature does not reveal which member of the group produced it, so the signer benefits from some k-anonymity. Unlike ring signatures, there is also a special party called the group manager who is able to determine the signer given the signature. Multi-signatures A set of arbitrary size \\(\\ell\\) can work together to produce a single signature on a shared message. Unlike threshold signatures, the (minimum) number of signers is not fixed upfront and can vary; furthermore, the identities of the signers are not hidden, and in fact a goal of the scheme is to be able to prove that everyone in the stated group of signers agreed to produce the signatures.  Compare to threshold signatures (see also the discussion on page 34 of [Bol03]). Ring signatures Like group signatures, a member of the \"ring\" (group) can produce a signature on behalf of everyone in the group while remaining anonymous. Compare to group signatures. Threshold signatures signing/secret key is split into secret shares; producing a signature requires some threshold number of shares. A threshold signature should be indistinguishable from an ordinary signature. Additionally, no single party should ever learn the secret key."},{"location":"Cryptographic-Primitives/signatures/#security-notions","title":"Security Notions","text":"EUF-CMA <p>Existential UnForgeability under adaptive Chosen Message Attacks, aka \"existential unforgeability\".</p> <p>EUF-CMA game</p> <ol> <li>Challenger: \\(pk,sk \\gets \\mathsf{Gen}(1^n)\\)</li> <li>\\(\\mathcal{A}(pk)\\) interacts with \\(\\mathsf{Sign}(sk,\\cdot)\\) (in polynomial time) \u2013 that is, it gets to see polynomially many valid signatures on chosen messages</li> <li>\\(\\mathcal{A}\\) outputs a message-signature pair \\(m^*,\\sigma^*\\)</li> </ol> <p>\\(\\mathcal{A}\\) wins if (1) \\(m^*\\) wasn't one of the messages on which it queried the signing oracle and (2) \\(\\mathsf{Vrfy}(pk,m^*,\\sigma^*) = 1\\); in this case, the game outputs 1.</p> SUF-CMA <p>Strong UnForgeability under adaptive Chosen Message Attacks, aka \"strong unforgeability\".</p> <p>SUF-CMA game</p> <p>Same as the EUF-CMA game, only the winning condition changes:</p> <p>\\(\\mathcal{A}\\) wins if (1) \\((m^*,\\sigma^*)\\) wasn't one of the message-signature pairs on which it queried the signing oracle and (2) \\(\\mathsf{Vrfy}(pk,m^*,\\sigma^*) = 1\\); in this case, the game outputs 1.</p> <p>This is a stronger definition than EUF-CMA, since the attacker can win by forging a signature on a previously-queried message \\(m^*\\) as long as the signature is different, for example by \"mauling\" a valid signature without changing its validity. </p> <p>This might seem a bit odd -- what does it matter if the adversary produces a different signature? The message was already signed by an honest party, so the adversary isn't convincing anyone that the party signed something it didn't actually sign. However, this difference does end up being important in some applications where signatures are used as building blocks.</p> <ol> <li> <p>By this we mean the x-coordinate is 0 (the y-coordinate is uniquely defined -- up to reflection over the x-axis -- by the x-coordinate).\u00a0\u21a9</p> </li> </ol>"}]}